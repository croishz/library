<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body {margin:0;}
		[dir="rtl"] {direction:rtl;}
		[role="tablist"] {margin-top:20px;}
		[role="tablist"] > .scrollContainer {
			/* overflow-x: scroll; */
			overflow: hidden;
			border:1px solid #000;
			box-sizing: border-box;
		}
		[role="tablist"] .scroller {
			display:flex;
			margin:0 -6px;
			will-change:contents;
			transition: transform 400ms ease;
		}
		[role="tablist"] .scroller.test {
			transition: none;
		}
		[role="tablist"] [role="tab"] {padding:14px 20px; margin:0 6px; cursor: pointer; text-align:center;}
		[role="tablist"] [role="tab"]:nth-child(odd) {background-color:gold; flex-basis:140px; min-width:140px;}
		[role="tablist"] [role="tab"]:nth-child(even) {background-color:tan; flex-basis:auto;}
		[role="tablist"] [role="tab"][aria-selected="true"],
		[role="tablist"] [role="tab"].active,
		[role="tabpanel"].active {background-color:lightcoral; color:#fff;}
		/* ui elements */
		[role="tablist"] button {border:none; padding:0; margin:0; font:1rem inherit inherit;}
		[role="tablist"] .indicator button {padding:4px 10px; cursor: pointer;}

		/* sample variation */
		#tab1 .scrollContainer {
			width:45%;
			min-width:500px;
		}
	</style>
</head>
<body>

	<div id="tab1" role="tablist" data-rootName="tablist1" aria-label="tab ui sample">
		<div class="scrollContainer">
			<div class="scroller">
				<button type="button" id="tab01" role="tab" aria-controls="tab_panel01" aria-selected="false">tab01</button>
				<button type="button" id="tab02" role="tab" aria-controls="tab_panel02" aria-selected="false" tabindex="-1">tab02</button>
				<button type="button" id="tab03" role="tab" aria-controls="tab_panel03" aria-selected="false" tabindex="-1">tab03</button>
				<button type="button" id="tab04" role="tab" aria-controls="tab_panel04" aria-selected="false" tabindex="-1">tab04</button>
				<button type="button" id="tab05" role="tab" aria-controls="tab_panel05" aria-selected="false" tabindex="-1">tab05</button>
				<button type="button" id="tab06" role="tab" aria-controls="tab_panel06" aria-selected="false" tabindex="-1">tab06</button>
				<button type="button" id="tab07" role="tab" aria-controls="tab_panel07" aria-selected="false" tabindex="-1">tab07</button>
			</div>
		</div>
		<div class="indicator" aria-controls="tab1">
			<button type="button" aria-disabled="true" tabindex="-1" aria-label="Previous tab">Prev</button>
			<button type="button" aria-disabled="true" tabindex="-1" aria-label="Next tab">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul id="tab1_panels" role="none">
		<li id="tab_panel01" role="tabpanel" aria-labelledby="tab01">Panel-01</li>
		<li id="tab_panel02" role="tabpanel" aria-labelledby="tab02">Panel-02</li>
		<li id="tab_panel03" role="tabpanel" aria-labelledby="tab03">Panel-03</li>
		<li id="tab_panel04" role="tabpanel" aria-labelledby="tab04">Panel-04</li>
		<li id="tab_panel05" role="tabpanel" aria-labelledby="tab05">Panel-05</li>
		<li id="tab_panel06" role="tabpanel" aria-labelledby="tab06">Panel-06</li>
		<li id="tab_panel07" role="tabpanel" aria-labelledby="tab07">Panel-07</li>
	</ul>
	<!-- // #tab1 -->
	
	<div id="tab2" role="tablist" dir="rtl">
		<div class="scrollContainer">
			<div class="scroller">
				<div role="tab" class="tab">tab01</div>
				<div role="tab" class="tab">tab02</div>
				<div role="tab" class="tab">tab03</div>
				<div role="tab" class="tab">tab04</div>
				<div role="tab" class="tab">tab05</div>
				<div role="tab" class="tab">tab06</div>
				<div role="tab" class="tab">tab07</div>
			</div>
		</div>
		<div class="indicator">
			<button type="button">Prev</button>
			<button type="button">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul role="none">
		<li role="tabpanel">Panel-01</li>
		<li role="tabpanel">Panel-02</li>
		<li role="tabpanel">Panel-03</li>
		<li role="tabpanel">Panel-04</li>
	</ul>
	<!-- // #tab2 -->
	<!-- <script>
		function ContextTest(root){
			this.root = root;
			this.check = 0;
			const context = this;
			// const handler = {
			ContextTest.prototype.handler = {
				handleEvent : function(e){
					console.log("handler: ", this);
					switch(e.type){
						case "mousedown" : this.start.call(context, e); break;
						case "mousemove" : this.move.call(context, e); break;
						case "mouseup" : this.end.call(context, e); break;
						default : break;
					}
					return;
				},
				start : function(e){
					console.log("func this:", this);
					console.log(context);
					console.log(ContextTest.prototype);
					// context.check++;
					// if(10 < context.check){
					// 	console.log("unbind");
					// 	ContextTest.prototype.eventUnbind();
					// }
				},
				move : function(e){
					console.log("func this:", this);
					console.log(context);
					console.log(ContextTest.prototype);
					// context.check++;
					// if(10 < context.check){
					// 	console.log("unbind");
					// 	ContextTest.prototype.eventUnbind();
					// }
				},
				end : function(e){
					console.log("func this:", this);
					console.log(context);
					console.log(ContextTest.prototype);
				}
			}
			ContextTest.prototype.eventBind = function(){
				this.root.addEventListener("mousedown", this.handler, false);	
			}
			ContextTest.prototype.eventUnbind = function(){
				this.root.removeEventListener("mousedown", this.handler, false);
			}
			this.eventBind();
		}
		const test1 = new ContextTest(document.querySelector("#tab1"));
		const test2 = new ContextTest(document.querySelector("#tab2"));
	</script> -->
	<script>
		function Tab(config){
			// constructor value
			this.name = config.rootElement.getAttribute("data-rootname") || config.rootElement.getAttribute("id") || config.rootElement.getAttribute("class");
			this.rollerSelector = config.rollerSelector || ".scroller";
			this.indicatorSelector = config.indicatorSelector || ".indicator";
			this.indicatorUseage = config.indicatorUseage || "scroll";
			this.activeClass = config.activeClassOnTab || "active";
			this.activeIndex = config.startIndex || 0;
			this.beforeIndex = this.activeIndex;
			this.addBindKeys = config.addBindKeys || {};
			// initialize
			this.scrollHandler = null;
			this.containerWidth = null;
			this.boundRange = null;
			// DOM
			this.rootElement = config.rootElement;
			this.tabUnits = config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(".tab");
			this.tabPanelWrap = config.panelWarpElement || document.querySelector(`${config.rootElement.getAttribute("id")}_panels`) || config.rootElement.nextElementSibling;
			this.tabPanels = Array.prototype.map.call(this.tabPanelWrap.children, child => child);
			this.indicator = config.indicator || config.rootElement.querySelector(`${this.indicatorSelector}`);
			this.arrows = Array.prototype.map.call(this.indicator.children, child => child);
			this.roller = this.rootElement.querySelector(`${this.rollerSelector}`);
			// Flag
			this.webAccessibility = config.webAccessibility || false;
			this.isAutomaticTab = config.focusWithPosition === "automatic" ? true : false; 
			this.isRTL = config.direction === "rtl" ? true : false;
			this.debug = config.debug || false;

			// action
			const NEXT_TAB = "NEXT";
			const PREV_TAB = "PREV";
			const FIRST_TAB = "FIRST";
			const LAST_TAB = "LAST";
			const CHOOSE = "CHOOSE";
			const SWIPE_START = "SWIPE_START";
			const SWIPE_MOVE = "SWIPE_MOVE";
			const SWIPE_END = "SWIPE_END";
			const STEADY = "STEADY";
			
			// log style
			const flowStyle = "color:#49b777; font-size:15px; background-color:#f9f9f9; padding:4px 8px; border:1px solid tan;";
			const APIStyle = "color:lightcoral; font-size:14px; font-weight:600; text-decoration:underline; font-style:italic;"
			const scrollHandler = "color:lightcoral";

			// prototype method
			Tab.prototype.dispatch = function(action, data){
				if(this.debug){
					console.group();
					console.log("%cDispatch", flowStyle)
					console.log("action:", action);
					console.log("data:", data);
					console.groupEnd();
				}
				// something do this
				
				return [action, data];
			}
			// tab event
			Tab.prototype.tabEvent = function(){
				// tab button
				if(this.tabUnits){
					this.tabUnits.forEach(
						unit => {
							// by click
							unit.addEventListener("click", ({type, currentTarget})=>{
								if(this.debug){
									console.group();
									console.log(`%cEvent: ${type}`, flowStyle);
									console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", currentTarget === unit);
									console.groupEnd();
								}
								
								const action = event.type === "click" && CHOOSE;
								const index = {index : this.getIndex(unit)};
								action && this.eventBinder( this.dispatch(action, index) );

								return false;
							});
							// by keyup
							unit.addEventListener("keyup", ({type, currentTarget, keyCode})=>{
								if(this.debug){
									console.group();
									console.log(`%cEvent: ${type} / ${keyCode}`, flowStyle);
									// console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", currentTarget === unit);
									console.groupEnd();
								}

								const action = this.keyChecker(keyCode);
								const index = {index : this.activeIndex};
								action && this.eventBinder( this.dispatch(action, index) );
								
								return false;
							});
						}
					);
				}else{ return new Error("No tab buttons!"); }
				// Arrow button
				if(this.arrows){
					this.arrows.forEach(
						arrow => {
							arrow.addEventListener("click", ({type, currentTarget})=>{
								const label = arrow.getAttribute("aria-label");

								if(this.debug){
									console.group();
									console.log(`%cIndicator: ${type}`, flowStyle);
									console.log("Arrow: ", label);
									console.groupEnd();
								}

								if(this.indicatorUseage === "index"){
									const action = label ? this.indicatorChecker(label) : Array.prototype.findIndex.call(target.parentElement.children,  arrow => arrow === target) === 0 ? PREV_TAB : NEXT_TAB;
									const index = {index : this.activeIndex};
									this.eventBinder( this.dispatch(action, index) );
								}
								
								return false;
							});
						}
					)
				}else{ return new Error("No arrow buttons!"); }
			};
			Tab.prototype.getIndex = function(_this){	
				const siblings = _this.parentElement.children;
				const index = Array.prototype.findIndex.call(siblings, sibling=> sibling === _this);   

				if(this.debug){
					console.group();
					console.log(`%cGet index : ${index}`, flowStyle);
					console.log(index === this.activeIndex);
					console.groupEnd();
				}
				return index;
			};
			Tab.prototype.indicatorChecker = function(_label){
				if(this.debug){
					console.group();
					console.log(`%cIndicator check: ${_label}`, flowStyle);
					console.groupEnd();
				}
				const action = {
					"Previous tab" : PREV_TAB,
					"Next tab" : NEXT_TAB
				}

				return action[_label]; 
			};
			Tab.prototype.keyChecker = function(_keyCode){
				const KeyMore = this.isRTL ? {} : this.addBindKeys;
				const keyList = Object.assign({
					// default keys;
					"40" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"39" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"38" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"37" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"36" : FIRST_TAB,
					"35" : LAST_TAB,
					"13" : CHOOSE
				}, KeyMore);
				const action = keyList[`${_keyCode}`]; 

				if(this.debug){
					console.group();
					console.log(`%cKey check: ${_keyCode}`, flowStyle);
					console.log("add key: ", KeyMore);
					console.groupEnd();
				}

				return action;
			};
			Tab.prototype.eventBinder = function([_action, _data]){
				if(this.debug){
					console.group();
					console.log("%cEvent bind", flowStyle);
					console.log("bind event: ", _action);
					console.log("data: ", _data);
					console.log("this: ", this);
				}

				// bind dependency
				let dep = null;
				const depType = {
					INDEX : "INDEX",
					SCREEN_POSITION : "SCREEN_POSITION",
				}

				// variable for INDEX;
				let index = (_data.index === null || _data.index === undefined) ? this.activeIndex : _data.index;
				const maxIndex = this.tabUnits.length - 1; // 6
				const minIndex = 0;
				
				// variable for SCREEN_POSITION;
				const direction = this.isRTL ? 1 : -1;
				const screenX = _data.screenX || _data.index !== undefined && _data.screenX;
				const screenPosition = {
					x : null,
					distance_x : 0,
					startPoint : null,
				};
				let lastX = null;

				switch(_action){
					case "CHOOSE" :
						dep = depType.INDEX;
						index = index;
						break;
					case "FIRST" : 
						dep = depType.INDEX;
						index = minIndex;
						break;
					case "LAST" : 
						dep = depType.INDEX;
						index = maxIndex;
						break;
					case "PREV" : 
						dep = depType.INDEX;
						index = minIndex >= index ? minIndex : index - 1;
						break;
					case "NEXT" : 
						dep = depType.INDEX;
						index = maxIndex <= index ? maxIndex : index + 1;
						break;
					case "SWIPE_START" : 
						dep = depType.SCREEN_POSITION;
						this.roller.classList.add("test");
						lastX = screenX;
						console.log(lastX);
						// this.roller.addEventListener("mousedown", this.scrollHandler, false);
						window.addEventListener("mousemove", this.scrollHandler, false);
						window.addEventListener("mouseup", this.scrollHandler, false);
						break;
					case "SWIPE_MOVE" : 
						dep = depType.SCREEN_POSITION;
						lastX = (screenX - lastX) * direction;
						console.log(lastX);
						this.animate(lastX);
						break;
					case "SWIPE_END" : 
						dep = depType.SCREEN_POSITION;
						this.roller.classList.remove("test");
						// this.roller.removeEventListener("mousedown", this.scrollHandler, false);
						window.removeEventListener("mousemove", this.scrollHandler, false);
						window.removeEventListener("mouseup", this.scrollHandler, false);
						break;
					case "STEADY" :
					default : 
						console.log("%cFlow end!", "font-size:24px;");
						console.groupEnd();
						return;
				}

				if(dep === depType.INDEX){
					// component value update;
					this.beforeIndex = this.activeIndex;
					this.activeIndex = index;
	
					const viewFlag = (this.isAutomaticTab || _action === CHOOSE) ? true : false;
					this.UiUpdate(index, viewFlag);
	
					if(this.debug){
						console.log(`Active index : %c${this.activeIndex}`, "color:red; font-size:16px; text-transform:uppercase;");
						console.log(`Index sync check : %c${this.activeIndex === this.index}`, "color:red; font-size:16px; text-transform:uppercase;");
					}
				}

				if(this.debug){
					console.log("%cFlow end!", "font-size:24px;");
					console.groupEnd();
				}

				return this;
			};
			// UI update
			Tab.prototype.UiUpdate = function(_index, _viewFlag){
				if(this.debug){
					console.group();
					console.log("%cUI update", flowStyle);
					console.log("index: ", _index);
					console.log("view flag: ", _viewFlag);
					console.log("focus element [before]: ", document.activeElement);
				}

				const roller = this.roller;
				const distance = this.calculateAPI.scrollPosition.call(this, _index);
				
				// view update;
				if(_viewFlag){
					this.markActive(_index);
					this.setFocus(_index);
				}else{
					this.setFocus(_index);
				}

				this.animate(distance, roller);
				
				if(this.debug){
					console.log("focus element [after]: ", document.activeElement);
					console.groupEnd();
				}
			};
			Tab.prototype.setFocus = function(_index){
				if(this.debug){
					console.group();
					console.log("%cSet Focus: ", flowStyle);
					console.log("Go to: ", _index);
					console.log("this: ", this);				
				}
				
				this.tabUnits[_index].focus();

				if(this.debug){
					console.groupEnd();
				}
			};
			Tab.prototype.markActive = function(_index){
				if(this.debug){
					console.group();
					console.log("%cMarking Active tab", flowStyle);
					console.log("this: ", this);
					console.log("this context index: ", this.activeIndex);
					console.log("param index: ", _index);
					console.log("use wai-aria:", this.webAccessibility);
					console.groupEnd();
				}
				const index = _index || this.activeIndex;
				const tabUnits = this.tabUnits;
				const tabPanels = this.tabPanels;
				const activeClass = this.activeClass;
				const activeUnit = tabUnits[index];
				const activePanel = tabPanels[index];
				const useWA = this.webAccessibility;

				// set attribute
				tabUnits.forEach((unit, i) => {
					unit.tabIndex = -1;
					useWA ? unit.setAttribute("aria-selected", false) : unit.classList.remove(activeClass);
					if(index === i){
						unit.tabIndex = 0;
						useWA ? unit.setAttribute("aria-selected", true) : unit.classList.add(activeClass);
					}
				});
				
				tabPanels.forEach((panel, i) => {
					panel.classList.remove(activeClass);
					panel.removeAttribute("tabindex");
					// panel.tabIndex = -1;
					if(index === i){ 
						panel.classList.add(activeClass); 
						panel.tabIndex = 0;
					}
				});
			};
			// animate
			Tab.prototype.animate = function(_distance, _roller = this.roller){
				const distance = this.wallHeat(_distance);
				if(this.debug){
					console.group();
					console.log("%cAnimate", flowStyle);
					console.log("roller:", _roller);
					console.log("distance:", _distance);
					console.groupEnd();
				}
				_roller.style.transform = `matrix(1,0,0,1,${distance},0)`
			};
			Tab.prototype.wallHeat = function(_distance){
				let distance = _distance;
				const [leftRange, rightRange] = this.boundRange;

				if( 0 <= distance && leftRange < distance){
					this.debug && console.log("Heat right wall!!");
					distance = leftRange;
				};
				if( 0 > distance && rightRange > distance ) {
					this.debug && console.log("Heat left wall!!");
					distance = rightRange;
				};

				return distance;
			}
			// scroll event
			Tab.prototype.swipeStart = function(_event){
				console.log("Start!");
				console.log(this);
				
				const action = SWIPE_START;
				const screenX = {screenX : _event.touches ? _event.touches[0].screenX : _event.screenX};
				this.eventBinder( this.dispatch(action, screenX));
			};
			Tab.prototype.swipeMove = function(_event){
				console.log(this);
				console.log(_event);

				const action = SWIPE_MOVE;
				const screenX = {screenX : _event.touches ? _event.touches[0].screenX : _event.screenX};
				this.eventBinder( this.dispatch(action, screenX));
			};
			Tab.prototype.swipeEnd = function(_event){
				console.log("End!");
				console.log(this);
				
				const action = SWIPE_END;
				const screenX = {screenX : _event.touches ? _event.touches[0].screenX : _event.screenX};
				this.eventBinder( this.dispatch(action, screenX));
			};
			Tab.prototype.swipeLifeCycle = function(){
				// console.log(this);
				const dispatch = Tab.prototype.dispatch.bind(this);
				const eventBinder = Tab.prototype.eventBinder.bind(this);
				const swipe_start = Tab.prototype.swipeStart.bind(this);
				const swipe_ing = Tab.prototype.swipeMove.bind(this);
				const swipe_end = Tab.prototype.swipeEnd.bind(this);

				return function handleEvent(_event){
					if(this.debug){
						console.group();
						console.log("handleEvent: ", this);
						console.log(`%c${_event.type}`, "font-size:30px;");
						console.groupEnd();
					}

					switch(_event.type){
						case "mousedown" :
						case "touchstart" :
							swipe_start(_event);
							break; 
						case "mousemove" : 
						case "touchmove" : 
							swipe_ing(_event);
							break;
						case "mouseup" : 
						case "touchend" : 
							swipe_end(_event);
							break;
						default : 
							return;
					}
	
					return false;
				}
			};
			Tab.prototype.swipe = function(){
				this.roller.addEventListener("mousedown", this.scrollHandler, false);
			};
			Tab.prototype.closedSwipe = function(){
				this.roller.removeEventListener("mousedown", this.scrollHandler, false);
			};
			
			// calculate
			Tab.prototype.getRenderStyleValue = function(_element, _needValue){
				if(this.debug){
					console.group();
					console.log(_element);
					console.groupEnd();
				}

				const measure = /[px, em, rem, vw, vh, %]/gi;
				let value = window.getComputedStyle(_element, null).getPropertyValue(_needValue);
				0 <= value.search(measure) ? value = parseInt(value.replace(measure, "")) : value;

				return value;
			};
			Tab.prototype.calculateAPI = (function(){
				const API = {
					tabMargin : function(_index){
						const element = this.tabUnits[_index];
						const marginOneSide = this.getRenderStyleValue(element, "margin-left"); 

						if(this.debug){
							console.group();
							console.log(`%cCalc.margin: ${marginOneSide}`, APIStyle);
							console.groupEnd();
						}

						return marginOneSide;
					},
					scrollPosition : function(_index){
						const element = this.tabUnits[_index];
						const direction = this.isRTL ? 1 : -1;
						const elemMargin = this.calculateAPI.tabMargin.call(this, _index);
						const elemOffsetRight = element.offsetLeft + element.offsetWidth;
						const elemOffsetLeft = this.isRTL ? ( (this.containerWidth - 1) - (elemOffsetRight - elemMargin) ) : element.offsetLeft; 
						const position = this.isRTL ? elemOffsetLeft * direction : (elemOffsetLeft - elemMargin) * direction;
						
						if(this.debug){
							console.group();
							console.log(`%cCalc.position: ${position}`, APIStyle);
							// console.log(element);
							// console.log(this.containerWidth);
							// console.log(element.offsetLeft);
							// console.log(element.offsetWidth);
							// console.log(elemOffsetLeft);
							// console.log(position);
							console.groupEnd();
						}
						return position;
					},
					scrollContainerWidth : function(){
						const width = this.rootElement.querySelector(".scrollContainer").offsetWidth;

						if(this.debug){
							console.group();
							console.log("%cCalc.scroll_container_width", APIStyle);
							console.log(`${this.name} : %c${width}`, "color:#fff; font-size:13px; padding:3px 5px; background-color:#333;");
							console.groupEnd();
						}
						return width;
					},
					scrollBeltWidth : function(_index = this.activeIndex){ 
						const scrollItem = this.rootElement.querySelectorAll("[role=tab]");
						const scrollItemMargin = this.calculateAPI.tabMargin.call(this, _index);
						const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
						const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

						if(this.debug){
							console.group();
							console.log(scrollItem);
							console.log(`baseWidth : ${baseWidth}`);
							console.log(`totalWidth : ${totalWidth}`);
							console.groupEnd();
						}

						return totalWidth;
					},
					scrollBoundRange : function(containerWidth){
						const scrollBeltWidth = this.scrollBeltWidth = this.calculateAPI.scrollBeltWidth.call(this);
						const boundaryConst = 0;
						const leftRange = Math.floor( containerWidth * (0 + boundaryConst) );
						const rightRange = Math.floor( (containerWidth - scrollBeltWidth) * (1 + boundaryConst) );
						const boundRange = this.isRTL ? [(rightRange * -1), leftRange] : [(leftRange * -1), rightRange];
						
						if(this.debug){
							console.group();
							console.log(`%cCalculate.scrollBoundRange`, APIStyle);
							console.log("this:", this);
							console.log(`leftRange : ${leftRange}`);
							console.log(`rightRange : ${rightRange}`);
							console.groupEnd();
						}

						return boundRange;
					}
				};
				return API;
			})();
			// initialize
			Tab.prototype.create = function(){
				console.group();
				console.log(`%cCreate ${this.name}`, flowStyle);
				// console.log("proto : ", this);
				this.containerWidth = this.calculateAPI.scrollContainerWidth.call(this);
				this.boundRange = this.calculateAPI.scrollBoundRange.call(this, this.containerWidth);

				/* pre setting */
				const initialFocus = true;
				const startIndex = this.activeIndex;
				const roller = this.roller;
				const distance = this.calculateAPI.scrollPosition.call(this, startIndex);
							
				this.tabUnits.forEach( (unit, idx) => startIndex === idx && ( this.webAccessibility ? (unit.setAttribute("aria-selected", true), unit.tabIndex = 0) : unit.tabIndex = 0 ) );			
				this.markActive(startIndex);
				this.setFocus(startIndex);
				// this.UiUpdate(this.activeIndex, initialFocus);
				
				/* event listening */
				// tab
				this.tabEvent();

				// scroll
				this.scrollHandler = this.swipeLifeCycle();
				this.swipe();

				// indicator
				// this.indicatorEvent();

				// re-rendering
				// this.resizeEvent();
				
				console.log("create done!")
				console.groupEnd();
				
				return this;
			};
			this.create();
		}
		const tenKey = {
			"104" : "PREV",
			"100" : "PREV",
			"102" : "NEXT",
			"98" : "NEXT",
			"103" : "FIRST",
			"97" : "LAST"
		}
		const tab = document.querySelectorAll("[role=tablist]");
		const tablist1 = new Tab({
			rootElement : tab[0],
			focusWithPosition : "manual",
			indicatorUseage : "index",
			startIndex : 1,
			webAccessibility : true,
			addBindKeys : tenKey,
			// debug : true,
		});
		const tablist2 = new Tab({
			rootElement : tab[1],
			focusWithPosition : "automatic",
			indicatorUseage : "scroll",
			startIndex : 4,
			direction : "rtl",
			// debug : true,
		});
		// tablist1.swipe = tablist1.swipe.bind(tablist1);
		// tablist2.swipe = tablist2.swipe.bind(tablist2);
		// tablist1.swipe();
		// tablist2.swipe();
	</script>
	<!-- <script>
		const TabScroller = (function(){
			function TabScroller(root){
				this.root = root;
				this.tabButton = this.root.querySelectorAll("[role=tab]") || this.root.querySelectorAll(".tab");
				TabScroller.prototype.event = function(){
					console.log(this.tabButton);
					this.tabButton.forEach( tab => tab.addEventListener("click", function(event){
						console.log("event:click");
						const siblings = this.parentElement.children;
						const index = Array.prototype.findIndex.call(siblings, sibling => sibling === this);
						TabScroller.prototype.markActive(index);
					}))
				};
				TabScroller.prototype.markActive = function(index){
					console.log(this);
					console.log(TabScroller);
					console.log(index);
					console.log(TabScroller.tabButton[index]);
				}
			}
			return TabScroller;
		})();
		const Tab = document.querySelectorAll("[role=tablist]");
		const tabList1 = new TabScroller(Tab[0]);
		const tabList2 = new TabScroller(Tab[1]);
		console.log(tabList1);
		console.log(tabList2);
		tabList1.event();
		tabList2.event();
	</script> -->
	<!-- <script>
		'use district';
		const tabUI = document.querySelectorAll("[role=tablist]");
		const initialConfig = [
			// tabList1
			{
				rootElement : tabUI[0],
				activeIndex : 3,
				webAccessibility : true
			},
			// tabLis2
			{
				rootElement : tabUI[1],
				tabSelector : ".tab",
				activeIndex : 0
			}
		];
		
		const tabList = initialConfig.reduce((acc, config, idx)=>{
			config.rootElement = tabUI[idx];
			acc[idx] = new Tab(config);
			return acc;
		},[]);
		// console.log(tabList);

		function Tab(config){
			this.rootElement = config.rootElement;
			this.tabUnits = config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(`${config.tabSelector}`);
			this.activeIndex = config.activeIndex || 0;
			this.activeClass = config.activeClass || "active";

			const isWA = this.webAccessibility = config.webAccessibility || false;
			const activeTabUnit = this.tabUnits[this.activeIndex];
			const scroller = this.rootElement.querySelector(".scroller");
			const activeClass = `${this.activeClass}`;

			// P = Tab.prototype;
			A = Array.prototype;

			Tab.prototype.init = ()=>{
				console.log(this);

				// tab event
				this.tab();
			};
		
			
			const clickEvent = (event, _this)=>{
				// markActive
				const siblings = unit.parentElement.children;
				A.forEach.call(siblings, sibling => {
					sibling.classList.remove(activeClass);
					if(isWA) sibling.setAttribute("aria-selected", false);
				});
				unit.classList.add(activeClass);
				if(isWA) unit.setAttribute("aria-selected", true);
			}
			const pressedEvent = (event)=>{
				console.log(event);
			}
			const tabEvent = (event)=>{
				console.log(event);
				switch(event.type){
					case "click" : clickEvent(event); break;
					case "keyup" : pressedEvent(event); break;
				}
			}
			Tab.prototype.tab = function(){
				this.tabUnits.forEach((unit, index)=>{
					unit.addEventListener("click", tabEvent);
				});
			};

			this.tabEvent = {
				handleEvent : (event)=>{
					console.log(event);
					console.log(this);
					event.preventDefault();
					switch(event.type){
						case "click" : tabEvent.byClick(event); break;
						case "keyup" : tabEvent.byPressed(event); break;
					}
				},
				byClick : (event)=>{

				},
				byPressed : (event)=>{

				}
			}
			// Tab.prototype.getPositionIndex = function(_self){
			// 	const siblings = _this.parentElement.children;
			// 	this.activeIndex = A.findIndex.call(siblings, element => element === _self);
			// 	console.log(`Active index : ${this.activeIndex}`);		
			// };
			// Tab.prototype.markActive = function(index){
			// 	// console.log(this.activeIndex);
			// 	// console.log(this.tabUnits);
			// 	this.tabUnits[index].classList.add(`${this.activeClass}`);
				
			// 	if(isWA){
			// 		this.tabUnits[index].setAttribute("aria-selected", "true");
			// 	}
			// };
			// Tab.prototype.animate = function(target = scroller, distance){
			// 	// console.log(target);
			// 	// console.log(distance);
			// 	target.style.transform = `matrix(1,0,0,1,${distance},0)`
			// };
			Tab.prototype.init();

		}
	</script> -->
	<!-- <script>
		// scenario
		/*
			dom을 탐색하여 tablist 요소를 선택한다
			선택한 요소의 dom tree를 확인하다
				- ul/ol이 쓰였을 때 :
				- role=tablist와 role=tab이 직접적인 부모 자식이었을 때 :
				- role=tab이 role=tablist의 자손이었을 때 :
			
		*/
		const tabUI = document.querySelectorAll("[role=tablist]");
		// console.log(tabUI);

		// constructor
		function Tab(config){
			// destructuring config object
			const {rootElement, scrollingSelector, initialPosition, direction, useWA, callbacks, debug, tab, customizing} = config;
			const {startIndex} = tab;
			if(customizing){
				const {addBindKeys} = customizing.options;
			}
			// pre-setting 
			this.rootElement = rootElement;
			this.direction = direction ? -1 : 1;
			this.useWA = useWA;
			this.scrollingSelector = scrollingSelector
			this.scrollBoundRange = null;
			if(debug){
				this.debug = {
					calculate : false || debug.calculate
				};
			}

			// prototype filed
			const p = Tab.prototype;
			// common methods
			// CRUD
			p.create = ()=>{
				this.init();
			};
			p.read = (request)=>{
				console.log(this);
				return eval(`this.${request}`);
			};
			p.update = ()=>{
				console.log(update);
			};
			p.delete = ()=>{
				this.init = null;
			};
			p.init = ()=>{
				// All null value are initialize
				this.scrollBoundRange = this.calculate.scrollBoundRange(this.calculate.scrollContainerWidth(this.debug.calculate), this.debug.calculate);

				// Call API
				// this.scrollLifeCycleAPI();
				
				// tab
				this.tab();

				// method chaining base
				return p;
			}

			// tab event
			this.tabUnit = this.rootElement.querySelectorAll("[role=tab]");
			this.tabPanelUnit = this.rootElement.querySelectorAll("[roll=tabpanel]");
			this.PrevArrow = this.rootElement.querySelector("[aria-label='Previous tab']");
			this.NextArrow = this.rootElement.querySelector("[aria-label='Next tab']");
			this.activeIndex = startIndex || 0;
			// console.log(
			// 	this.PrevArrow,
			// 	this.NextArrow
			// )
			p.tab = ()=>{
				Array.prototype.map.call(this.tabUnit, (unit)=>{
					unit.addEventListener("click", (event)=>{
						console.log("click");
						// console.dir(event.currentTarget);
						// console.dir(event.target);
						event.preventDefault();
						const _this = event.target;
						p.getIndex(_this);
						p.setPositionByIndex(this.activeIndex, this.scroller);
						// const role = _this.TagName;
						// if(_this.getAttribute("role") === "tab"){
						// 	console.log("button:tab");
						// }
						// if(_this.getAttribute("aria-label") === "Previous tab"){
						// 	console.log("button:prev");
						// }
						// if(_this.getAttribute("aria-label") === "Next tab"){
						// 	console.log("button:next");
						// }
					});
				});

				this.rootElement.addEventListener("keyup", ({keyCode})=>{
					// console.dir(event.currentTarget);
					// console.dir(event.target);
					// console.dir(event);
					// console.log(keyCode);
					// event.preventDefault();

					const action = {
						NEXT_TAB : "NEXT",
						PREV_TAB : "PREV",
						FIRST_TAB : "FIRST",
						LAST_TAB : "LAST"
					}
					const {NEXT_TAB, PREV_TAB, FIRST_TAB, LAST_TAB} = action;
					const bindKeys = Object.assign({
						// case:ten key less 
						"40" : NEXT_TAB,
						"39" : NEXT_TAB,
						"38" : PREV_TAB,
						"37" : PREV_TAB,
						"36" : FIRST_TAB,
						"35" : LAST_TAB
					}, addBindKeys);
					// console.log(bindKeys);
					p.loadPosition(bindKeys[`${keyCode}`]);
					
				});
				return p;
			}
			p.loadPosition = (action)=>{
				switch(action){
					case "NEXT" : 
						console.log(action.NEXT_TAB);
						this.activeIndex = (this.tabUnit.length <= this.activeIndex + 1) ? this.activeIndex : this.activeIndex + 1;
						p.setPositionByIndex(this.activeIndex);
						break;
					case "PREV" : 
						console.log(action.PREV_TAB); 
						this.activeIndex = (0 > this.activeIndex - 1) ? this.activeIndex : this.activeIndex - 1;
						p.setPositionByIndex(this.activeIndex);
						break;
					case "FIRST" : 
						console.log(action.FIRST_TAB);
						p.setPositionByIndex(0);
						break;
					case "LAST" : 
						console.log(action.LAST_TAB); 
						p.setPositionByIndex(this.tabUnit.length);
						break;
					default : break;
				}
			}
			p.getIndex = (_this)=>{
				const _siblings = _this.parentElement.children;
				this.activeIndex = Array.prototype.findIndex.call(_siblings, (element)=> element === _this);
				console.log(`Active index : ${this.activeIndex}`);

				return p;
			}
			this.isAutoPositioning = true;
			p.setPositionByIndex = (index)=>{
				console.log(index);
				const chosenElement = this.tabUnit[index];
				console.dir();
				if(this.isAutoPositioning){
					const scrollItemMargin = parseInt(window.getComputedStyle(chosenElement, null).getPropertyValue("margin-left").replace("px", ""));
					const distance = (chosenElement.offsetLeft - scrollItemMargin) * -1;

					// console.log(distance, chosenElement.offsetLeft, scrollItemMargin);
					
					p.scrollAnimate(distance);
				}else{

				}
				return p;
			}

			// calculate methods
			p.calculate = {
				scrollContainerWidth : (debugFlag)=>{
					const width = this.rootElement.querySelector(".scrollContainer").offsetWidth;

					if(debugFlag){
						console.log(width);
					}
					
					return width;
				},
				scrollBeltWidth : (debugFlag)=>{ 
					const scrollItem = this.rootElement.querySelectorAll("[role=tab]");
					const scrollItemMargin = parseInt(window.getComputedStyle(scrollItem[0], null).getPropertyValue("margin-left").replace("px", ""));
					const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
					const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

					if(debugFlag){
						console.group();
						console.log(`scrollItem : ${scrollItem}`);
						console.log(`scrollItemMargin : ${scrollItemMargin}`);
						console.log(`baseWidth : ${scrollItemMargin}`);
						console.log(`totalWidth : ${scrollItemMargin}`);
						console.groupEnd();
					}

					return totalWidth;
				},
				scrollBoundRange : (containerWidth, debugFlag)=>{
					const leftRange = Math.floor( containerWidth * 0 );
					const rightRange = Math.floor( ( containerWidth - p.calculate.scrollBeltWidth(this.debug.calculate) ) * 1 );

					if(debugFlag){
						console.log(`leftRange : ${leftRange}`);
						console.log(`rightRange : ${rightRange}`);
					}

					return [leftRange, rightRange];
				}
			}
			/*
				scroll event lifecycle
				action => create => render => action => [update] => render
				action => create => render => action => [delete] => render(remove on view)
				
				- controller
				1. controller(user action, handlers:[START, MOVE, END], options, target:rootElement);
					- user action의 type에 따라 handler를 선택하며, 각기 수행한 이벤트의 정보를 반환한다.
						# createEvent(handlers:START[, options]) return event data
						# updateView(handlers:MOVE, options) return event data
						# deleteEvent(handlers:END) return event data
				- model
				1. model(event data) return data for render;
					- 이벤트 정보를 받아 view를 렌더링하기 위한 정보를 생성/가공한다.

				- render
				1. render(renderer, data:[calculate value, model])
					- 모델로부터 정보를 받아 view를 만든다.
				

				user action => scroll Event Triggered => mouse/touch point move => view re-action => user action stop/end => re-rendering n correction
				마우스 다운 => 스크롤 이벤트 등록 => 마우스 좌표 기반 계산값을 요소에 반영 => css transition => 마우스 업 => 요소 위치 결정 및 보정 (direction, over scroll....);
			*/
			p.scrollLifeCycle = (
				userAction = {
					"START" : ["touchstart", "mousedown"],
					"MOVE" : ["touchmove", "mousemove"],
					"END" : ["touchend", "mouseup"]
				}, 
				handlers, 
				options, 
				target = this.rootElement
			)=>{
				// controller
				let eventData = null;
				return ()=>{
					const API = this.scrollLifeCycleAPI;
					switch(userAction){
						case "START" :
							eventData = API.createEvent(userAction, handlers["START"], target, options = false);
							break;
						case "MOVE" :
							eventData = API.updateView(userAction, handlers["MOVE"], options);
							break;
						case "END" : 
							eventData = API.deleteEvent(userAction, handlers["END"]);
							break;
						default : 
							throw new Error("This is not defined action.(정의된 동작이 아닙니다)");
					}
				}
			}
			p.scrollLifeCycleAPIs = {
				initialized : (beforePosition) => {
					const element = this.rootElement.querySelector(`${this.scrollingSelector}`);
					this.scrollLifeCycleAPIs.render(element, beforePosition);
				},
				createEvent : (action, handler, target, options)=>{
					target.addEventListener(action, handler(options));
				},
				updateView : ()=>{

				},
				deleteEvent : ()=>{

				},
				modeling : ()=>{

				},
				render : (scroller, distance)=>{
					scroller.style.transform = `matrix(1, 0, 0, 1, ${distance}, 0)`;
				}
			}
			this.initialPosition = initialPosition || 0;
			this.scrollPosition = null;
			console.log(this.rootElement);
			this.scroller = this.rootElement.querySelector(`${this.scrollingSelector}`);
			const addTransition = (time = 300)=>{
				const tg = this.rootElement.querySelector(`${this.scrollingSelector}`);
				tg.setAttribute("style", `transition:transform ${time}ms ease`);
				setTimeout(()=>{
					tg.style.transition = "";
				}, 400);

				return true;
			};

			p.scrollAnimate = (distance, element = this.scroller)=>{
				console.log(element);
				element.style.transform = `matrix(1, 0, 0, 1, ${distance}, 0)`;
			}
			p.scrollLifeCycleAPI= ()=>{
				const target = this.rootElement;
				const START = "mousedown";
				const END = "mouseup";
				const MOVE = "mousemove";
				const touchPosition = {
					x : null,
					distance_x : 0,
					startPoint : null,
				};

				const callback = (triggerEvent)=>{
					const {currentTarget} = triggerEvent;
					const element = currentTarget.querySelector(`${this.scrollingSelector}`);
					console.log(currentTarget);
					console.log(element);
					touchPosition.x = triggerEvent.touches ? triggerEvent.touches[0].screenX : triggerEvent.screenX;
					touchPosition.startPoint = this.scrollPosition;

					return (moveEvent)=>{
						const movePosX = moveEvent.touches ? moveEvent.touches[0].screenX : moveEvent.screenX;
						const distance = movePosX - touchPosition.x;

						this.scrollPosition = touchPosition.startPoint + distance;
						p.scrollAnimate(this.scrollPosition, element);
					};
				};
				// switch
				console.log(target)
				target.addEventListener(START, (event)=>{
					const handler = callback(event);
					window.addEventListener(MOVE, handler, false);
					window.addEventListener(END, ()=>{
						window.removeEventListener(MOVE, handler, false);
						// const [leftRange, rightRange] = this.scrollBoundRange;
						// if(0 <= this.scrollPosition && leftRange < this.scrollPosition && addTransition()) this.scrollPosition = leftRange;
						// if(0 > this.scrollPosition && rightRange > this.scrollPosition && addTransition()) this.scrollPosition = rightRange;
						p.scrollAnimate(this.scrollPosition, this.scroller);
					}, false);
				}, false);
			}

			// web accessible methods
			if(useWA){
				p.accessibility = ()=>{
					console.log("ref wcag");
				}
			}
		}

		// useage
		const tabList = new Tab({
			rootElement : tabUI[0],
			scrollingSelector : ".scroller",
			direction : 1,
			initialPosition : -100,
			useWA : false,
			debug : {
				flag : false,
				calculate : false,
			},
			tab : {
				startIndex : 0,
			},
			customizing : {
				flag : true,
				options : {
					// ten key
					addBindKeys : {
						"104" : "PREV",
						"100" : "PREV",
						"102" : "NEXT",
						"98" : "NEXT",
						"103" : "FIRST",
						"97" : "LAST"
					},
				}
			}
		});
		tabList.create();
		console.log(tabList);
		// const approachConfig = tabList.read("calculate");
		// console.log(approachConfig);
		// tabList.delete();
		// console.log(tabList.init);

		const tabList2 = new Tab({
			rootElement : tabUI[1],
			scrollingSelector : ".scroller",
			direction : 1,
			initialPosition : -100,
			useWA : false,
			debug : {
				flag : false,
				calculate : false,
			},
			tab : {
				startIndex : 0,
			},
			customizing : {
				flag : true,
				options : {
					// ten key
					addBindKeys : {
						"104" : "PREV",
						"100" : "PREV",
						"102" : "NEXT",
						"98" : "NEXT",
						"103" : "FIRST",
						"97" : "LAST"
					},
				}
			}
		});
		console.log(tabList2);
	</script> -->
	<!-- <script>
		const start = document.getElementById("tab");
		function find(el){
			let findTg = null;
			let treeNestedDepth = 0;
			
			const findTgElement = ()=>{
				if (
					el.children[0].attributes.getNamedItem("role") !== null && 
					el.children[0].attributes.getNamedItem("role").value === "tab"
				){
					findTg = el.children;
					return findTg, treeNestedDepth;
				}else{
					let rebind = el.children[0];
					treeNestedDepth++;
					find.call(document, rebind);
				}
			}
			findTgElement();
		};
		function uiElementChecker(tgElements){
			console.log(tgElements);
			Array.map.call(tgElements, (el)=>{
				console.dir(el);
				el.tabIndex !== 0 && el.setAttribute("tabindex", 1);
			});
		};
		// scenario
		/*
		role=tablist를 root element로 하는 dom tree를 생성 또는 인지.
		screen fit에 맞춰 리사이징.
		한줄 정렬 시 스크롤 ui 제공.
		현재 탭의 위치 표시 및 index 리턴. by mouse, keyboard, touch, scroll.
		arrow, wheel로 스크롤 이동 시 
		index를 이용한 callback 사용 제공.
		index를 이용한 history stack 생성. 
		라이프 사이클 api 제공.
		커스텀 함수를 추가하여 확장가능하도록 최소 기능으로 한정.
		console.log를 통해 wai-aria의 맞지 않거나 미진한 부분을 작성자에게 전달.
		이후 carousel 케이스 추가.
		*/
		function interaction(eventObject, dispatch){
			const object = eventObject || {};
			if( 0 <= eventObject.type.indexOf("key")){
				object.type = "keyboardEvent"; 
			}
			return object;
		}

		function TabUI([
			root,
			direction,
			mediaMatches
		]){
			this.root = document.querySelectorAll(root);
			this.componentRoot =  this.root.forEach((el)=>{return el});
			this.direction = direction,
			this.mediaQuery = mediaMatches
			;
			const init = ()=>{
				focusable();
			}
			// static field
			const accessibilityError = (flag)=>{
				if(flag === false || flag === undefined) return flag;

				console.group();
				if(this.root.children().getAttribute("role") === tab && this.root.children().getAttribute("aria-labelledBy") === undefined ){
					console.log("accessible name을 지정해주세요.");
				}
				console.groupEnd();
			};
			const focusable = ()=>{
				console.log("focusable");
				console.log(this.componentRoot);
				document.querySelectorAll(root + " [role=tab]").forEach((children)=>{
					if(children.tabIndex !== 1) children.tabIndex = 1; 
				});
			};
			// 
			const interface = TabUI.prototype; 
			interface.positioning = (pos)=>{

			};
			interface.addEventListener = (eventType, callback)=>{
				return window.addEventListener.call(this.root[0], eventType, (eventObject) => {
					callback();
				});
			}
			interface.keyEvent = (callback)=>{
				window.addEventListener.call(this.root[0], "keydown", (event)=>{
					console.log(event);

					const actionType = interaction(event);
					console.log(actionType);
					if(event.__proto__.initKeyboardEvent){
						console.log(event.keyCode);
					}
				})
			}
			init();
		}
		const tab1 = new TabUI([
			"#tab",	// root
			"ltr",
			768
		]);
		tab1.keyEvent()
	</script> -->
</body>
</html>