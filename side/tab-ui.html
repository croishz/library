<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body {margin:0;}
		[dir="rtl"] {direction:rtl;}
		[role="tablist"] {margin-top:20px;}
		[role="tablist"] > .scrollContainer {
			overflow: hidden;
			/* overflow-y: unset;
			overflow-x: scroll; */
			border:1px solid #000;
			box-sizing: border-box;
		}
		[role="tablist"] .scroller {
			display:flex;
			margin:0 -6px;
			will-change:contents;
			transition: transform 400ms ease;
		}
		[role="tablist"] .scroller.test {
			transition: none;
		}
		[role="tablist"] .scroller.align-center {
			justify-content: center;
		}
		[role="tablist"] [role="tab"] {padding:14px 20px; margin:0 6px; cursor: pointer; text-align:center;}
		[role="tablist"] [role="tab"]:nth-child(odd) {background-color:gold; flex-basis:140px; min-width:140px;}
		[role="tablist"] [role="tab"]:nth-child(even) {background-color:tan; flex-basis:auto;}
		[role="tablist"] [role="tab"][aria-selected="true"],
		[role="tablist"] [role="tab"].active,
		[role="tabpanel"].active {background-color:lightcoral; color:#fff;}
		/* ui elements */
		[role="tablist"] button {border:none; padding:0; margin:0; font:1rem inherit inherit;}
		[role="tablist"] .indicator button {padding:4px 10px; cursor: pointer;}

		/* sample variation */
		/* #tab1 .scrollContainer {
			width:45%;
			max-width:500px;
			min-width:320px;
		} */
	</style>
</head>
<body>
	<div id="tab1" role="tablist" data-root-name="tablist1" aria-label="tab ui sample">
		<div class="scrollContainer">
			<div class="scroller">
				<button type="button" id="tab01" role="tab" aria-controls="tab1_panel01" aria-selected="false">tab01</button>
				<button type="button" id="tab02" role="tab" aria-controls="tab1_panel02" aria-selected="false" tabindex="-1">tab02</button>
				<button type="button" id="tab03" role="tab" aria-controls="tab1_panel03" aria-selected="false" tabindex="-1">tab03</button>
				<button type="button" id="tab04" role="tab" aria-controls="tab1_panel04" aria-selected="false" tabindex="-1">tab04</button>
				<button type="button" id="tab05" role="tab" aria-controls="tab1_panel05" aria-selected="false" tabindex="-1">tab05</button>
				<button type="button" id="tab06" role="tab" aria-controls="tab1_panel06" aria-selected="false" tabindex="-1">tab06</button>
				<button type="button" id="tab07" role="tab" aria-controls="tab1_panel07" aria-selected="false" tabindex="-1">tab07</button>
			</div>
		</div>
		<div class="indicator" aria-controls="tab1">
			<button type="button" aria-disabled="true" tabindex="-1" aria-label="Previous tab">Prev</button>
			<button type="button" aria-disabled="true" tabindex="-1" aria-label="Next tab">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul id="tab1_panels" role="none">
		<li id="tab1_panel01" role="tabpanel" aria-labelledby="tab01">Panel-01</li>
		<li id="tab1_panel02" role="tabpanel" aria-labelledby="tab02">Panel-02</li>
		<li id="tab1_panel03" role="tabpanel" aria-labelledby="tab03">Panel-03</li>
		<li id="tab1_panel04" role="tabpanel" aria-labelledby="tab04">Panel-04</li>
		<li id="tab1_panel05" role="tabpanel" aria-labelledby="tab05">Panel-05</li>
		<li id="tab1_panel06" role="tabpanel" aria-labelledby="tab06">Panel-06</li>
		<li id="tab1_panel07" role="tabpanel" aria-labelledby="tab07">Panel-07</li>
	</ul>
	<hr>
	<!-- // #tab1 -->
	
	<div id="tab2" role="tablist" dir="rtl">
		<div class="scrollContainer">
			<div class="scroller align-center">
				<div role="tab">tab01</div>
				<div role="tab">tab02</div>
				<div role="tab">tab03</div>
				<div role="tab">tab04</div>
				<div role="tab">tab05</div>
				<div role="tab">tab06</div>
				<div role="tab">tab07</div>
			</div>
		</div>
		<div class="indicator">
			<button type="button">Prev</button>
			<button type="button">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul role="none">
		<li role="tabpanel">Panel-01</li>
		<li role="tabpanel">Panel-02</li>
		<li role="tabpanel">Panel-03</li>
		<li role="tabpanel">Panel-04</li>
	</ul>
	<hr>
	<!-- // #tab2 -->

	<div class="tab3" role="tablist" dir="rtl">
		<div class="scrollContainer">
			<div class="scroller">
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
			</div>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul role="none">
		<li role="tabpanel"></li>
		<li role="tabpanel"></li>
		<li role="tabpanel"></li>
		<li role="tabpanel"></li>
	</ul>
	<hr>
	<!-- // .tab3 -->

	<!-- // .tab5 -->
	<h3>tab5</h3>
	<div class="tab-wrapper"></div>
	<hr>
	<!-- // .tab5 -->

	<template class="tab">
		<div class="*rootSelector*" data-root-name="*rootName*">
			<div class="scrollContainer">
				<ul class="scroller">
					<div class="tab"></div>
				</ul>
			</div>
		</div>
		<ul>
			<li class="tabpanel"></li>
		</ul>
	</template>
	<script>
		function Tab(config){
			/* Constructor method */
			// Create DOM
			const createHTML = (_opt)=>{
				let HTML = config.template;

				HTML =	HTML.replace(/\*rootSelector\*/g, _opt.root)
							.replace(/\*rootName\*/g, _opt.rootName);

				_opt.wrapperElement.innerHTML = HTML;
				// rootElement = document.querySelector(`.${_opt.root}`);
				const rootElement = config.rootElement = _opt.wrapperElement.children[0];
				return rootElement;
			};
			const matchLength = (_length)=>{
				if(_length <= this.tabUnits.length) return "aleady done";
				
				this.debug && console.log("loop before", this);
				this.debug && console.log("fill");

				const buttonWrap = this.tabUnits[0].parentElement;
				const panelWrap = this.tabPanelWrap;
				const button = this.tabUnits[0].outerHTML;
				const panel = this.tabPanels[0].outerHTML;
				let tabList = buttonWrap.innerHTML; 
				let tabpanel = panelWrap.innerHTML;

				for(let i=0; i < (_length - this.tabUnits.length); i++ ){
					this.debug && console.log(i);
					tabList += button;
					tabpanel += panel;
				}

				buttonWrap.innerHTML = tabList;
				panelWrap.innerHTML = tabpanel;
				
				// update DOM
				this.tabUnits = config.rootElement.querySelectorAll("[role=tab]").length > 0 && config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(".tab");
				this.tabUnits =  Array.prototype.map.call(this.tabUnits, child => child);
				this.tabPanels = Array.prototype.map.call(this.tabPanelWrap.children, child => child);

				this.debug && console.log("loop complete:", this);

				return "matched";
			};

			/* Constructor value */
			// Flag
			this.useScroll = config.useScroll || true;
			this.webAccessibility = config.webAccessibility || false;
			this.isAutomaticTab = config.focusWithPosition === "automatic" ? true : false; 
			this.isRTL = config.direction === "rtl" ? true : false;
			this.debug = config.debug || false;
			// DOM
			this.rootElement = config.template && createHTML(config.dynamicOptions) || config.rootElement;
			this.tabUnits = config.rootElement.querySelectorAll("[role=tab]").length > 0 && config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(".tab");
			this.tabUnits =  Array.prototype.map.call(this.tabUnits, child => child);
			this.tabPanelWrap = config.panelWarpElement || document.querySelector(`${config.rootElement.getAttribute("id")}_panels`) || config.rootElement.nextElementSibling;
			this.tabPanels = Array.prototype.map.call(this.tabPanelWrap.children, child => child);
			this.scrollerContainerSelector = this.useScroll && ( config.scrollerContainerSelector || ".scrollContainer" );
			this.scrollerContainer = this.useScroll && ( this.rootElement.querySelector(`${this.scrollerContainerSelector}`) );
			this.scrollerSelector = this.useScroll && ( config.scrollerSelector || ".scroller" );
			this.scroller = this.useScroll && ( this.rootElement.querySelector(`${this.scrollerSelector}`) );
			this.indicatorSelector = config.indicatorSelector || ".indicator";
			this.indicator = config.indicator || config.rootElement.querySelector(`${this.indicatorSelector}`);
			this.arrows = this.indicator && Array.prototype.map.call(this.indicator.children, child => child);
			this.tabLengthMatch = config.template && matchLength(config.tabLength) || "be matched manually";
			// Initialize value
			this.name = (this.debug || this.webAccessibility) && ( config.rootElement.getAttribute("data-root-name") || config.rootElement.getAttribute("id") || config.rootElement.getAttribute("class") );
			this.activeClass = config.activeClassOnTab || "active";
			this.activeIndex = config.startIndex || 0;
			this.beforeIndex = this.activeIndex;
			this.addBindKeys = config.addBindKeys || {};
			this.indicatorFor = config.indicatorFor || "scroll";
			this.debounceDuration = config.debounceDuration || 400;
			this.template = config.template || false;
			this.defaultFetchURL = config.fetchURL || "/";
			this.fetchByTab = config.fetchByTab || false;
			this.covertAriaMarkUp = null;
			this.swipeHandleEvent = null;
			this.containerWidth = null;
			this.scrollRange = null;
			this.position = {
				newPoint : null,
				startPoint : null,
				nowPoint : null
			};
			// Action type
			const NEXT_TAB = "NEXT";
			const PREV_TAB = "PREV";
			const FIRST_TAB = "FIRST";
			const LAST_TAB = "LAST";
			const CHOOSE = "CHOOSE";
			const SWIPE_START = "SWIPE_START";
			const SWIPE_MOVE = "SWIPE_MOVE";
			const SWIPE_END = "SWIPE_END";
			const STEADY = "STEADY";
			// Log style
			const flowStyle = "color:#49b777; font-size:15px; background-color:#f9f9f9; padding:4px 8px; border:1px solid tan;";
			const APIStyle = "color:lightcoral; font-size:14px; font-weight:600; text-decoration:underline; font-style:italic;"
			const scrollHandler = "color:lightcoral";
			
			/* Prototype method */
			// web accessibility
			Tab.prototype.convertWaiAriaMarkup = function(){
				if(this.debug){
					console.group();
					console.log("%cConver Markup", flowStyle);
				} 
				// catch DOM
				const tabList = this.rootElement;
				const scroller = this.scroller;
				const panelList = this.tabPanelWrap;
				const tabs = this.tabUnits;
				const panels = this.tabPanels;
				const indicator = this.indicator && this.indicator;
				const arrows = this.indicator && this.arrows;
				const initialIndex = this.activeIndex;
				let rootName = this.name;

				// Check n Convert markup
				const tabListCheck = tabList.getAttribute("role") === "tablist" ? true : tabList.setAttribute("role", "tablist");
				const panelListCheck = (panelList.nodeName !== "UL" && panelList.nodeName !== "OL") ? true : panelList.setAttribute("role", "none");
				const tabListTreeCheck = scroller.nodeName !== "LI" ? true : scroller.setAttribute("role", "none");
				
				const tabCheck = (()=>{
					tabs.map((tab, idx)=>{
						tab.setAttribute("role", "tab");
						tab.setAttribute("id", `${rootName}_tab${idx}`);
						tab.setAttribute("aria-controls", `${rootName}_panel_${idx}`);
						tab.setAttribute("aria-selected", false);
						initialIndex === idx &&  tab.setAttribute("aria-selected", true);
					})
					return true;
				})();
				
				const panelCheck = (()=>{
					panels.map((panel, idx)=>{
						panel.setAttribute("role", "tabpanel");
						panel.setAttribute("id", `${rootName}_panel_${idx}`);
						panel.setAttribute("aria-labelledby", `${rootName}_tab${idx}`);
					})
					return true;
				})();

				const indicatorCheck = (()=>{
					if(!this.indicator) return "reject";

					const rootID = tabList.getAttribute("id");
					0 >= rootID.length ? tabList.setAttribute("id", rootName) : rootID !== rootName ? rootName = rootID : rootName;
					indicator.setAttribute("aria-controls", rootName);
					
					arrows.map((arrow, idx)=>{
						if(this.aria){
							const prevLabel = this.aria.prevLabel ? this.aria.prevLabel : false; 
							const nextLabel = this.aria.nextLabel ? this.aria.nextLabel : false;
							idx === 0 && arrow.setAttribute( "aria-label", (prevLabel || arrow.innerText + "tab") );
							idx === 1 && arrow.setAttribute( "aria-label", (nextLabel || arrow.innerText + "tab") );
						}
						arrow.getAttribute("type") !== "button" && arrow.setAttribute("role", "button");
						arrow.setAttribute("aria-disabled", true);
						arrow.tabIndex = -1;
					});
					return true;
				})();
				
				const checkList = [tabListCheck, panelListCheck, tabListTreeCheck, tabCheck, panelCheck, indicatorCheck]
				const allCheck = checkList.filter( checker => (checker !== true && checker !== "reject") );

				if(this.debug){
					console.log("checkList: ", checkList);
					console.log("pass report: ", allCheck);
					console.groupEnd();
				}

				return allCheck.length > 0 ? true : false;
			}
			// fetch data
			Tab.prototype.fetchData = function(
				_callback,
				_url = this.defaultFetchURL,
				_dataType = "json", 
				_action = "get",
				_parseJSON = true
			){
				if(this.debug){
					console.group();
					console.log("%cFetch", flowStyle);
					console.trace();
					console.log(`action: ${_action}`);
					console.log(`data type: ${_dataType}`);
					console.log(`url: ${_url}`);
				}

				const xhr = new XMLHttpRequest();
				const callback = _callback.bind(this);
				const context = this;

				xhr.responseType = _dataType;
				xhr.onload = function(){
					if(this.debug){
						console.log("%cAJAX request", flowStyle);
						console.log(context.name);
						// console.log("context:", context);
						// console.log("this:", this);
						console.log("xhr:", xhr);
					}

					const response = this.response;
					callback(response);
					
					this.debug && console.groupEnd();
				};
				xhr.onerror = function(err){
					throw error(err);

					if(this.debug){
						console.log(`Error code: ${this.status}`);
						console.groupEnd();
					}
				};
				xhr.open(_action, _url, _parseJSON);
				xhr.send();
			};
			// temporary method
			Tab.prototype.fetchCallback = function(_response){
				if(!_response) return;

				const data = _response.product;
				
				if(this.debug){
					console.group();
					console.log("%cFetch callback", flowStyle);
					console.trace();
					console.log(this);
					console.log(data);
				}

				data.map((contents, idx)=>{
					const unit = this.tabUnits[idx];
					const panel = this.tabPanels[idx];
					unit && (unit.innerText = contents.id);
					panel && (panel.innerText = contents.copy);
				});

				this.debug && console.groupEnd();

				return this;
			};
			// flow
			Tab.prototype.dispatch = function(action, data){
				if(this.debug){
					console.group();
					console.log("%cDispatch", flowStyle)
					console.log("action:", action);
					console.log("data:", data);
					console.groupEnd();
				}
				// something do this
				
				return [action, data];
			}
			Tab.prototype.eventBinder = function([_action, _data]){
				if(this.debug){
					console.group();
					console.log("%cEvent bind", flowStyle);
					console.log("bind event: ", _action);
					console.log("data: ", _data);
					console.log("this: ", this);
				}

				// bind dependency
				let dep = null;
				const depType = {
					INDEX : "INDEX",
					SCREEN_POSITION : "SCREEN_POSITION",
				}

				// variable for INDEX;
				const maxIndex = this.tabUnits.length - 1; // 6
				const minIndex = 0;
				let index = (_data.index === null || _data.index === undefined) ? this.activeIndex : _data.index;
				
				// variable for SCREEN_POSITION;
				const screenX = (_data.screenX === null || _data.index !== undefined) ? this.positionX : _data.screenX;
				// const direction = this.isRTL ? 1 : -1;
				const direction = -1;

				switch(_action){
					case "CHOOSE" :
						dep = depType.INDEX;
						index = index;
						if(config.dynamicFetch && this.fetchByTab) this.fetchData(this.fetchCallback);
						break;
					case "FIRST" : 
						dep = depType.INDEX;
						index = minIndex;
						break;
					case "LAST" : 
						dep = depType.INDEX;
						index = maxIndex;
						break;
					case "PREV" : 
						dep = depType.INDEX;
						index = minIndex >= index ? minIndex : index - 1;
						break;
					case "NEXT" : 
						dep = depType.INDEX;
						index = maxIndex <= index ? maxIndex : index + 1;
						break;
					case "SWIPE_START" : 
						dep = depType.SCREEN_POSITION;
						this.scroller.classList.add("test");

						// this.scroller.parentElement.addEventListener("mousedown", this.swipeHandleEvent, false);
						window.addEventListener("mousemove", this.swipeHandleEvent, false);
						window.addEventListener("mouseup", this.swipeHandleEvent, false);
						
						// this.scroller.parentElement.addEventListener("touchstart", this.swipeHandleEvent, false);
						// window.addEventListener("touchmove", this.swipeHandleEvent, false);
						// window.addEventListener("touchEnd", this.swipeHandleEvent, false);

						this.position.newPoint = screenX;
						this.position.startPoint = this.position.nowPoint;
						
						if(this.debug){
							console.group();
							console.log("swipe start point: ", this.position.newPoint);
							console.groupEnd();
						}
						break;
					case "SWIPE_END" : 
						dep = depType.SCREEN_POSITION;
						this.scroller.classList.remove("test");

						// this.scroller.parentElement.removeEventListener("mousedown", this.swipeHandleEvent, false);
						window.removeEventListener("mousemove", this.swipeHandleEvent, false);
						window.removeEventListener("mouseup", this.swipeHandleEvent, false);

						// this.scroller.parentElement.removeEventListener("touchstart", this.swipeHandleEvent, false);
						// window.removeEventListener("touchmove", this.swipeHandleEvent, false);
						// window.removeEventListener("touchEnd", this.swipeHandleEvent, false);

						if(this.debug){
							console.log(this.position.newPoint);
							console.log(screenX);						
							console.log(SWIPE_END);
						}

						if(this.position.newPoint !== screenX) {
							console.log("did to swipe");
							// this.position.nowPoint = this.animate(this.wallHeat(this.position.nowPoint));
							this.position.nowPoint = this.animate(this.position.nowPoint);
						};
						break;
					case "SWIPE_MOVE" : 
						dep = depType.SCREEN_POSITION;
						const distance = (screenX - this.position.newPoint) * direction;
						this.position.nowPoint = this.position.startPoint - distance;
						this.animate(this.position.nowPoint, true);

						if(this.debug){
							console.group();
							console.log("this.position.startPoint:", this.position.startPoint);
							console.log("distance: ", distance);
							console.log("mouse point: ", this.position.nowPoint);
							console.groupEnd();
						}
						break;
					case "STEADY" :
					default : 
						console.log("%cFlow end!", "font-size:24px;");
						console.groupEnd();
						return;
				}

				if(dep === depType.INDEX){
					// component value update;
					this.beforeIndex = this.activeIndex;
					this.activeIndex = index;
					
					const viewFlag = (this.isAutomaticTab || _action === CHOOSE) ? true : false;
					const roller = this.scroller;
					const distance = this.calculateAPI.scrollPosition.call(this, index);
					
					if(this.debug){
						console.log("%cUI update", flowStyle);
						console.log("index: ", index);
						console.log("view flag: ", viewFlag);
						console.log("focus element [before]: ", document.activeElement);
					}
					// view update;
					if(viewFlag){
						this.markActive(index);
						this.setFocus(index);
					}else{
						this.setFocus(index);
					}

					// this.position.nowPoint = this.animate(this.wallHeat(distance));
					this.position.nowPoint = this.animate(distance);
					
					if(this.debug){
						console.log("focus element [after]: ", document.activeElement);
						console.log(`Active index : %c${this.activeIndex}`, "color:red; font-size:16px; text-transform:uppercase;");
						console.log(`Index sync check : %c${this.activeIndex === this.index}`, "color:red; font-size:16px; text-transform:uppercase;");
					}
				}

				if(this.debug){
					console.log("%cFlow end!", "font-size:24px;");
					console.groupEnd();
				}

				return this;
			};
			// animate
			Tab.prototype.animate = function(_distance, _moveflag = false, _roller = this.scroller){
				// const distance = _distance;
				const distance = _moveflag ? _distance : this.wallHeat(_distance);

				if(this.debug){
					console.group();
					console.log("%cAnimate", flowStyle);
					console.log("roller:", _roller);
					console.log("distance:", _distance);
					console.groupEnd();
				}
				
				_roller.style.transform = `matrix(1,0,0,1,${distance},0)`

				return distance;
			};
			Tab.prototype.wallHeat = function(_distance){
				let distance = _distance;
				const [leftLimit, rightLimit] = this.scrollRange;

				if(this.debug){
					console.group();
					console.log(_distance);
					console.log("leftLimit: ", leftLimit);
					console.log("rightLimit: ", rightLimit);
				}

				if( 0 <= distance && leftLimit < distance){
					this.debug && console.log("Heat right wall!!");
					distance = leftLimit;
				}
				if( 0 > distance && rightLimit > distance ) {
					this.debug && console.log("Heat left wall!!");
					distance = rightLimit;
				};

				this.debug && console.groupEnd();
				return distance;
			};
			// tab event
			Tab.prototype.tabEvent = function(){
				// tab button
				if(this.tabUnits){
					this.tabUnits.forEach(
						unit => {
							// by click
							unit.addEventListener("click", ({type, currentTarget})=>{
								if(this.debug){
									console.group();
									console.log(`%cEvent: ${type}`, flowStyle);
									console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", currentTarget === unit);
									console.groupEnd();
								}
								
								const action = event.type === "click" && CHOOSE;
								const index = {index : this.getIndex(unit)};
								action && this.eventBinder( this.dispatch(action, index) );

								return false;
							});
							// by keyup
							unit.addEventListener("keyup", ({type, currentTarget, keyCode})=>{
								if(this.debug){
									console.group();
									console.log(`%cEvent: ${type} / ${keyCode}`, flowStyle);
									// console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", currentTarget === unit);
									console.groupEnd();
								}

								const action = this.keyChecker(keyCode);
								const index = {index : this.activeIndex};
								action && this.eventBinder( this.dispatch(action, index) );

								return false;
							});
						}
					);
				}else{ return new Error("No tab buttons!"); }
			};
			Tab.prototype.indicatorEvent = function(_flag){
				const flag = _flag === "tab" ? true : false;
				// Arrow button
				if(this.arrows){
					this.arrows.forEach(
						arrow => {
							arrow.addEventListener("click", ({type, target})=>{
								const label = arrow.getAttribute("aria-label");

								if(true){
									console.group();
									console.log(`%cIndicator: ${type}`, flowStyle);
									console.log("Arrow: ", label);
									console.groupEnd();
								}

								if(this.indicatorFor === "tab"){
									const action = label ? this.indicatorChecker(label) : Array.prototype.findIndex.call(target.parentElement.children,  arrow => arrow === target) === 0 ? PREV_TAB : NEXT_TAB;
									const index = {index : this.activeIndex};
									this.eventBinder( this.dispatch(action, index) );
								}
								
								return false;
							});
						}
					)
				}else{ return new Error("No arrow buttons!"); }
			}
			Tab.prototype.getIndex = function(_this){	
				const siblings = _this.parentElement.children;
				const index = Array.prototype.findIndex.call(siblings, sibling=> sibling === _this);   

				if(this.debug){
					console.group();
					console.log(`%cGet index : ${index}`, flowStyle);
					console.log(index === this.activeIndex);
					console.groupEnd();
				}
				return index;
			};
			Tab.prototype.keyChecker = function(_keyCode){
				const KeyMore = this.isRTL ? {} : this.addBindKeys;
				const keyList = Object.assign({
					// default keys;
					"40" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"39" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"38" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"37" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"36" : FIRST_TAB,
					"35" : LAST_TAB,
					"13" : CHOOSE
				}, KeyMore);
				const action = keyList[`${_keyCode}`]; 

				if(this.debug){
					console.group();
					console.log(`%cKey check: ${_keyCode}`, flowStyle);
					console.log("add key: ", KeyMore);
					console.groupEnd();
				}

				return action;
			};
			Tab.prototype.setFocus = function(_index){
				if(this.debug){
					console.group();
					console.log("%cSet Focus: ", flowStyle);
					console.log("Go to: ", _index);
					console.log("this: ", this);				
				}
				
				this.tabUnits[_index].focus();

				if(this.debug){
					console.groupEnd();
				}

				return this;
			};
			Tab.prototype.markActive = function(_index){
				if(this.debug){
					console.group();
					console.log("%cMarking Active tab", flowStyle);
					console.log("this: ", this);
					console.log("this context index: ", this.activeIndex);
					console.log("param index: ", _index);
					console.log("use wai-aria:", this.webAccessibility);
					console.groupEnd();
				}

				const index = _index || this.activeIndex;
				const tabUnits = this.tabUnits;
				const tabPanels = this.tabPanels;
				const activeClass = this.activeClass;
				const activeUnit = tabUnits[index];
				const activePanel = tabPanels[index];
				const useWA = this.webAccessibility;

				// set attribute
				tabUnits.map((unit, i) => {
					unit.tabIndex = -1;
					useWA ? unit.setAttribute("aria-selected", false) : unit.classList.remove(activeClass);
					if(index === i){
						unit.tabIndex = 0;
						useWA ? unit.setAttribute("aria-selected", true) : unit.classList.add(activeClass);
					}
				});
				
				tabPanels.map((panel, i) => {
					panel.classList.remove(activeClass);
					panel.removeAttribute("tabindex");
					if(index === i){ 
						panel.classList.add(activeClass); 
						panel.tabIndex = 0;
					}
				});

				return this;
			};
			// scroll event
			Tab.prototype.swipe = function(){
				this.debug && console.log("attach swipe");
				this.scroller.parentElement.addEventListener("mousedown", this.swipeHandleEvent, false);
				// this.scroller.parentElement.addEventListener("touchstart", this.swipeHandleEvent, false);

				return this;
			};
			Tab.prototype.closedSwipe = function(){
				this.debug && console.log("dettach swipe");
				this.scroller.parentElement.removeEventListener("mousedown", this.swipeHandleEvent, false);
				// this.scroller.parentElement.removeEventListener("touchstart", this.swipeHandleEvent, false);
				
				return this;
			};
			Tab.prototype.swipeLifeCycle = function(_action, _event){
				const action = _action;
				const screenX = {screenX : _event.touches ? _event.touches[0].screenX : _event.screenX};

				if(this.debug){
					console.group();
					console.log("action: ", _action);
					console.log("event: ", _event);
					console.log("this: ", this);
					console.groupEnd();
				}
				
				this.eventBinder( this.dispatch(action, screenX) );
				
				return this;
			}
			Tab.prototype.swipeHandler = function(){
				const context = this;
				const dispatch = Tab.prototype.dispatch.bind(this);
				const eventBinder = Tab.prototype.eventBinder.bind(this);
				const start = Tab.prototype.swipeLifeCycle.bind(this);
				const ing = Tab.prototype.swipeLifeCycle.bind(this);
				const end = Tab.prototype.swipeLifeCycle.bind(this);
			
				return function handleEvent(_event){
					const isTouchEvent = _event.touches ? true : false;
					this.isTouchEvent = isTouchEvent;

					if(this.debug){
						console.group();
						console.log("handleEvent: ", this);
						console.log("context: ", context);
						console.log("byTouch: ", isTouchEvent);
						console.log(`%c${_event.type}`, "font-size:30px;");
						console.groupEnd();
					}

					switch(_event.type){
						case "mousedown" :
						case "touchstart" :
							// console.log("st", _event);
							start(SWIPE_START, _event);
							break; 
						case "mousemove" : 
						case "touchmove" : 
							// console.log("swp", _event);
							ing(SWIPE_MOVE, _event);
							break;
						case "mouseup" : 
						case "touchend" : 
							// console.log("ed", _event);
							end(SWIPE_END, _event);
							break;
						default : 
							return;
					}

					_event.stopPropagation();
				}
			};
			Tab.prototype.hangInSwipe = function(_containerWidth, _scrollBeltWidth){
				if(this.debug){
					console.group();
					console.log(`%cHang in Swipe`, flowStyle);
					console.log(this.name);
					console.log("breakpoint: ", _containerWidth);
					console.log("swipe activate: ", _containerWidth <= _scrollBeltWidth);
				}

				if(_containerWidth <= _scrollBeltWidth){
					this.swipe();
				}else{
					this.closedSwipe();
				}

				if(this.debug){	
					console.groupEnd();
				}

				return this;
			}
			// indicator event
			Tab.prototype.indicatorChecker = function(_label){
				if(this.debug){
					console.group();
					console.log(`%cIndicator check: ${_label}`, flowStyle);
					console.groupEnd();
				}
				const action = {
					"Previous tab" : PREV_TAB,
					"Next tab" : NEXT_TAB
				}

				return action[_label]; 
			};
			// resize event
			Tab.prototype.resizeHandler = function(_onResize){	
				// re bind calculate api
				const calcAPI = this.calculateAPI;
				const calcContainerWidth = calcAPI.scrollContainerWidth.bind(this);
				const calcBeltWidth = calcAPI.scrollBeltWidth.bind(this);
				const calcRange = calcAPI.scrollRange.bind(this);
				const calcPosition = calcAPI.scrollPosition.bind(this);
				// debounce
				let debounce = null;
				const debounceDuration = this.debounceDuration;
				// for handleEvent block
				const context = this;
				const onResize = _onResize && _onResize.bind(this);

				return function handleEvent(_event){
					const time = Date.now();
					clearTimeout(debounce);
					debounce = setTimeout(()=>{
						if(context.debug){
							console.group();
							console.log("debounce");
							console.log(context);
						}

						// update dimension
						context.containerWidth = calcContainerWidth();
						context.scrollBeltWidth = calcBeltWidth();
						context.scrollRange = calcRange(context.containerWidth, context.scrollBeltWidth);
						context.position.nowPoint = calcPosition(context.activeIndex);
						// use swipe check
						context.hangInSwipe(context.containerWidth, context.scrollBeltWidth);
						// call custom api if exist
						onResize && onResize(context);
						// refresh scroll position
						context.animate( context.wallHeat(context.position.nowPoint) );

						if(context.debug){
							console.log("Debounce duration: ", Date.now() - time );
							console.groupEnd();
						}
					}, debounceDuration);
				}
			}
			// calculate
			Tab.prototype.getRenderStyleValue = function(_element, _needValue){
				if(this.debug){
					console.group();
					console.log(_element);
					console.groupEnd();
				}

				const measure = /[px, em, rem, vw, vh, %]/gi;
				let value = window.getComputedStyle(_element, null).getPropertyValue(_needValue);
				0 <= value.search(measure) ? value = parseInt(value.replace(measure, "")) : value;

				return value;
			};
			Tab.prototype.calculateAPI = (function(){
				const API = {
					tabMargin : function(_index){
						if(this.debug){
							console.group();
							console.log(_index);
							console.log(this);
							console.log(this.tabUnits);
						}
						const element = this.tabUnits[_index];
						const marginOneSide = this.getRenderStyleValue(element, "margin-left"); 

						if(this.debug){
							console.log(`%cCalc.margin: ${marginOneSide}`, APIStyle);
							console.groupEnd();
						}

						return marginOneSide;
					},
					scrollPosition : function(_index){
						const element = this.tabUnits[_index];
						const direction = this.isRTL ? 1 : -1;
						const elemMargin = this.calculateAPI.tabMargin.call(this, _index);
						const elemOffsetRight = element.offsetLeft + element.offsetWidth;
						const elemOffsetLeft = this.isRTL ? ( (this.containerWidth - 1) - (elemOffsetRight - elemMargin) ) : element.offsetLeft; 
						const position = this.isRTL ? elemOffsetLeft * direction : (elemOffsetLeft - elemMargin) * direction;
						
						if(this.debug){
							console.group();
							console.log(`%cCalc.position: ${position}`, APIStyle);
							console.log("element: ", element);
							console.log("this.containerWidth: ", this.containerWidth);
							console.log("element.offsetLeft: ", element.offsetLeft);
							console.log("element.offsetWidth: ", element.offsetWidth);
							console.log("elemOffsetLeft: ", elemOffsetLeft);
							console.log("position: ", position);
							console.groupEnd();
						}

						return position;
					},
					scrollContainerWidth : function(){
						const width = this.scrollerContainer.offsetWidth;

						if(this.debug){
							console.group();
							console.log("%cCalc.scroll_container_width", APIStyle);
							console.log(`${this.name} : %c${width}`, "color:#fff; font-size:13px; padding:3px 5px; background-color:#333;");
							console.groupEnd();
						}
						
						return width;
					},
					scrollBeltWidth : function(_index = this.activeIndex){ 
						const scrollItem = this.tabUnits;
						const scrollItemMargin = this.calculateAPI.tabMargin.call(this, _index);
						const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
						const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

						if(this.debug){
							console.group();
							console.log(scrollItem);
							console.log(`baseWidth : ${baseWidth}`);
							console.log(`totalWidth : ${totalWidth}`);
							console.groupEnd();
						}

						return totalWidth;
					},
					scrollRange : function(_containerWidth, _scrollBeltWidth){
						const coverageRatio = 1;
						const leftLimit = Math.floor( _containerWidth * 0 );
						const rightLimit = _containerWidth > _scrollBeltWidth ? 0 : Math.floor( (_containerWidth - _scrollBeltWidth) * 1 );
						const boundRange = this.isRTL ? [(rightLimit * -1), leftLimit] : [leftLimit, rightLimit];
						
						if(this.debug){
							console.group();
							console.log(`%cCalculate.scrollRange`, APIStyle);
							console.log("this:", this);
							console.log(_containerWidth);
							console.log(_scrollBeltWidth);
							console.log(`leftRange : ${leftLimit}`);
							console.log(`rightRange : ${rightLimit}`);
							console.groupEnd();
						}

						return boundRange;
					}
				};
				return API;
			})();
			// Create
			Tab.prototype.create = function(){
				if(this.debug){
					console.group();
					console.time("create");
					console.log(`%cCreate: ${this.name}`, flowStyle);
				}

				// Convert markup for web accessibility
				this.webAccessibility && (this.covertAriaMarkUp = this.convertWaiAriaMarkup());
				// Pre setting
				const initialIndex = this.activeIndex;
				this.markActive(initialIndex);
				this.setFocus(initialIndex);
				// Event listening
				this.tabEvent();		// tab
				this.indicatorEvent();	// indicator
				if(this.useScroll){
					// calculate for swipe
					this.containerWidth = this.calculateAPI.scrollContainerWidth.call(this);
					this.scrollBeltWidth = this.calculateAPI.scrollBeltWidth.call(this);
					this.scrollRange = this.calculateAPI.scrollRange.call(this, this.containerWidth, this.scrollBeltWidth);

					// swipe 
					this.swipeHandleEvent = this.swipeHandler();
					this.hangInSwipe(this.containerWidth, this.scrollBeltWidth);

					// re-rendering
					const customAPIOnResize = this.customAPI && this.customAPI.resize;
					const resizeHandleEvent = this.resizeHandler(customAPIOnResize);
					window.addEventListener("resize", resizeHandleEvent);
					this.customAPI && customAPIOnResize.call(this, this);
				}

				if(this.debug){
					console.timeEnd("create");
					console.log("create done!");
					console.groupEnd();
				}
				
				return this;
			};
			
			// init TAB
			config.dynamicFetch && this.fetchData(this.fetchCallback);
			config.autoCreate && this.create();
		}
		const tenKey = {
			"104" : "PREV",
			"100" : "PREV",
			"102" : "NEXT",
			"98" : "NEXT",
			"103" : "FIRST",
			"97" : "LAST"
		}
		const tab = document.querySelectorAll("[role=tablist]");
		const tablist1 = new Tab({
			rootElement : tab[0],
			indicatorFor : "tab",
			webAccessibility : true,
			autoCreate : true,
			// debug : true,
		});
		const tablist2 = new Tab({
			rootElement : tab[1],
			focusWithPosition : "automatic",
			indicatorFor : "scroll",
			startIndex : 4,
			direction : "rtl",
			autoCreate : false,
			// debug : true,
		});
		tablist2.customAPI = {
			resize : function(_context){
				// console.group();
				// console.log(_context);
				// console.log(this);
				// console.groupEnd();
				
				const cw = _context.containerWidth;
				const scw = _context.scrollBeltWidth;
				const classList = _context.scroller.classList;

				cw <= scw ? classList.remove("align-center") : classList.add("align-center");
			}
		}
		tablist2.create();
		
		// dynamic data
		const tablist3 = new Tab({
			rootElement : document.querySelector(".tab3"),
			dynamicFetch : true,
			fetchURL : "./ajax-test/listData.json",
			fetchByTab : false,
			focusWithPosition : "manual",
			startIndex : 0,
			autoCreate : true,
			direction : "rtl",
			// debug : true,
		});

		// dynamic markup
		// by ajax
		function fetchHTML(_tabObject, _opt, _url, _action = "get"){
			const xhr = new XMLHttpRequest();
			const url = _url || _opt.template;

			_action === "post" &&
			xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			
			xhr.onreadystatechange = function(){
				if( xhr.readyState === xhr.DONE && xhr.status === 200 ){
					// const dynamicHTML = new DOMParser().parseFromString(xhr.response, "text/xml").firstElementChild;
					const dynamicHTML = document.createRange().createContextualFragment(xhr.response);
					document.body.appendChild(dynamicHTML);

					// console.log(typeof xhr.response);
					// console.dir(dynamicHTML);
					
					_opt.rootElement =  document.querySelector(_opt.rootElement);
					_tabObject = new Tab(_opt);
					console.log(_tabObject);
				}else{
					// throw error
				}
			};
			
			xhr.open(_action, _url);
			xhr.send();
		}
		let tablist4 = null;
		const tablist4Options = {
			rootElement : "#tab4",
			focusWithPosition : "manual",
			indicatorFor : "tab",
			startIndex : 0,
			autoCreate : true,
			dynamicFetch : true,
			fetchURL : "./ajax-test/listData.json",
			webAccessibility : true,
			// debug : true,
		};
		fetchHTML(tablist4, tablist4Options, "./ajax-test/markup.html");
		// by template
		const templateClone = function(_dom){
			_dom.remove();
			return _dom.innerHTML;
		}
		const tablist5 = new Tab({
			template : templateClone(document.querySelector("template.tab")),
			dynamicOptions : {
				wrapperElement : document.querySelector(".tab-wrapper"),
				root : "tab5",
				rootName : "tablist5"
			},
			tabLength : 7,
			dynamicFetch : true,
			fetchURL : "./ajax-test/listData.json",
			fetchByTab : false,
			focusWithPosition : "manual",
			indicatorFor : "tab",
			startIndex : 0,
			autoCreate : true,
			webAccessibility : true,
			// debug : true,
		});
		</script>
</body>
</html>