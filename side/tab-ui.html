<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body {margin:0;}
		[dir="rtl"] {direction:rtl;}
		[role="tablist"] {margin-top:20px;}
		[role="tablist"] > .scrollContainer {
			/* overflow-x: scroll; */
			overflow: hidden;
			border:1px solid #000;
			box-sizing: border-box;
		}
		[role="tablist"] .scroller {
			display:flex;
			margin:0 -6px;
			will-change:contents;
			transition: transform 400ms ease;
		}
		[role="tablist"] [role="tab"] {padding:14px 20px; margin:0 6px; cursor: pointer;}
		[role="tablist"] [role="tab"]:nth-child(odd) {background-color:lightcoral; flex-basis:140px; min-width:140px;}
		[role="tablist"] [role="tab"]:nth-child(even) {background-color:gainsboro; flex-basis:auto;}
		[role="tablist"] [role="tab"][aria-selected="true"],
		[role="tabpanel"].active {background-color:#fff; color:rgb(74, 150, 236);}
		/* ui elements */
		[role="tablist"] button {border:none; padding:0; margin:0; font:1rem inherit inherit;}
		[role="tablist"] .indicator button {padding:4px 10px; cursor: pointer;}

		/* sample variation */
		#tab1 .scrollContainer {
			width:45%;
			min-width:500px;
		}
	</style>
</head>
<body>

	<div id="tab1" role="tablist" data-rootName="test1" aria-label="tab ui sample">
		<div class="scrollContainer">
			<div class="scroller">
				<button type="button" id="tab01" role="tab" aria-controls="tab_panel01" aria-selected="false">tab01</button>
				<button type="button" id="tab02" role="tab" aria-controls="tab_panel02" aria-selected="false" tabindex="-1">tab02</button>
				<button type="button" id="tab03" role="tab" aria-controls="tab_panel03" aria-selected="false" tabindex="-1">tab03</button>
				<button type="button" id="tab04" role="tab" aria-controls="tab_panel04" aria-selected="false" tabindex="-1">tab04</button>
				<button type="button" id="tab05" role="tab" aria-controls="tab_panel05" aria-selected="false" tabindex="-1">tab05</button>
				<button type="button" id="tab06" role="tab" aria-controls="tab_panel06" aria-selected="false" tabindex="-1">tab06</button>
				<button type="button" id="tab07" role="tab" aria-controls="tab_panel07" aria-selected="false" tabindex="-1">tab07</button>
			</div>
		</div>
		<div class="indicator" aria-controls="tab1">
			<button type="button" aria-disabled="false" aria-label="Previous tab">Prev</button>
			<button type="button" aria-disabled="false" aria-label="Next tab">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul id="tab1_panels" role="none">
		<li id="tab_panel01" role="tabpanel" aria-labelledby="tab01" class="active">Panel-01</li>
		<li id="tab_panel02" role="tabpanel" aria-labelledby="tab02">Panel-02</li>
		<li id="tab_panel03" role="tabpanel" aria-labelledby="tab03">Panel-03</li>
		<li id="tab_panel04" role="tabpanel" aria-labelledby="tab04">Panel-04</li>
		<li id="tab_panel05" role="tabpanel" aria-labelledby="tab05">Panel-05</li>
		<li id="tab_panel06" role="tabpanel" aria-labelledby="tab06">Panel-06</li>
		<li id="tab_panel07" role="tabpanel" aria-labelledby="tab07">Panel-07</li>
	</ul>

	<div id="tab2" role="tablist" dir="rtl">
		<div class="scrollContainer">
			<div class="scroller">
				<div role="tab" class="tab">tab01</div>
				<div role="tab" class="tab">tab02</div>
				<div role="tab" class="tab">tab03</div>
				<div role="tab" class="tab">tab04</div>
				<div role="tab" class="tab">tab05</div>
				<div role="tab" class="tab">tab06</div>
				<div role="tab" class="tab">tab07</div>
			</div>
		</div>
		<div class="indicator" aria-controls="tab2">
			<button type="button" aria-disabled="false" aria-label="Previous tab">Prev</button>
			<button type="button" aria-disabled="false" aria-label="Next tab">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul role="none">
		<li role="tabpanel" class="active">Panel-01</li>
		<li role="tabpanel">Panel-02</li>
		<li role="tabpanel">Panel-03</li>
		<li role="tabpanel">Panel-04</li>
	</ul>
	<script>
		function Tab(config){
			this.rootElement = config.rootElement;
			this.tabUnits = config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(".tab")
			this.tabPanelWrap = config.panelWarpElement || document.querySelector(`${config.rootElement.getAttribute("id")}_panels`) || config.rootElement.nextElementSibling;
			this.tabPanels = Array.prototype.map.call(this.tabPanelWrap.children, child => child);
			this.indicator = config.indicator || config.rootElement.querySelector(".indicator");
			this.rollerSelector = config.rollerSelector || ".scroller";
			this.roller = this.rootElement.querySelector(`${this.rollerSelector}`);
			this.activeIndex = config.startIndex || 0;
			this.activeClass = config.activeClassOnTab || "active";
			this.beforeIndex = this.activeIndex;
			this.webAccessibility = config.webAccessibility || false;
			this.addBindKeys = config.addBindKeys || {};
			this.isAutomaticTab = config.focusWithPosition === "automatic" ? true : false; 
			this.isRTL = config.direction === "rtl" ? true : false;

			const self = this;	// for prototype method call;
			const addBindKeys = this.addBindKeys;

			// action
			const NEXT_TAB = "NEXT";
			const PREV_TAB = "PREV";
			const FIRST_TAB = "FIRST";
			const LAST_TAB = "LAST";
			const CHOOSE = "CHOOSE";
			const KeyMore = this.isRTL ? {} : this.addBindKeys;

			// log style
			const flowStyle = "color:steelblue; font-size:15px; background-color:#f9f9f9; padding:4px 8px; border:1px solid tan;";
			const APIStyle = "color:lightcoral; font-size:14px; font-weight:600; text-decoration:underline; font-style:italic;"
			// debug
			const debugFlag = false;
			Tab.prototype.API = function(something){
				something();
			};
			Tab.prototype.dispatch = function(action, data){
				
				console.group();
				console.log("%cDispatch", flowStyle)
				console.log("action:", action);
				console.log("data:", data);
				console.groupEnd();

				// something do this

				return [action, data];
			}
			Tab.prototype.tabEvent = function(){
				// tab button
				if(this.tabUnits){
					this.tabUnits.forEach(
						unit => {
							// by click
							unit.addEventListener("click", ({type, target})=>{
								if(debugFlag){
									console.group();
									console.log(`%cEvent: ${type}`, flowStyle);
									console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", target === unit);
									console.groupEnd();
								}
								
								const action = event.type === "click" && CHOOSE;
								const index = self.getIndex(unit);
								self.eventBinder(
									self.dispatch(action, index)
								);
							});
							// by keyup
							unit.addEventListener("keyup", ({type, target, keyCode})=>{
								if(debugFlag){
									console.group();
									console.log(`%cEvent: ${type} / ${keyCode}`, flowStyle);
									console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", target === unit);
									console.groupEnd();
								}

								const action = self.keyChecker(keyCode);
								const index = this.activeIndex;
								self.eventBinder(
									self.dispatch(action, index)
								)
							});
						}
					);
				}
				// Arrow button
				if(this.indicator){
					Array.prototype.forEach.call(
						this.indicator.children, 
						arrow => {
							arrow.addEventListener("click", ({target})=>{
								event.stopPropagation();
								const label = arrow.getAttribute("aria-label");
								
								console.group();
								console.log(`%cIndicator: ${target}`, flowStyle);
								console.log("Arrow: ", label);
								console.groupEnd();
								
								// const classifyArrow = ()=>{
								// 	const action = Array.prototype.findIndex.call(target.parentElement.children,  arrow => arrow === target) === 0 ? PREV_TAB : NEXT_TAB;
								// 	return action;
								// }
								const action = label ? this.indicatorChecker(label) : Array.prototype.findIndex.call(target.parentElement.children,  arrow => arrow === target) === 0 ? PREV_TAB : NEXT_TAB;
								const index = this.activeIndex;
								self.eventBinder(
									self.dispatch(action, index)
								);
							});
						}
					)
				}
			};
			Tab.prototype.getBeforeIndex = function(){
				console.group();
				console.log("%cGet before index: ", flowStyle);
				console.log("this: ", this);
				console.groupEnd()
				return this.beforeIndex = this.activeIndex;
			};
			Tab.prototype.getIndex = function(_this){	
				const siblings = _this.parentElement.children;
				const index = Array.prototype.findIndex.call(siblings, sibling=> sibling === _this);   

				console.group();
				console.log(`%cGet index : ${index}`, flowStyle);
				console.log(index === this.activeIndex);
				console.groupEnd();

				return index;
			};
			Tab.prototype.indicatorChecker = function(_label){
				console.group();
				console.log(`%cIndicator check: ${_label}`, flowStyle);
				console.groupEnd();

				const action = {
					"Previous tab" : PREV_TAB,
					"Next tab" : NEXT_TAB
				}

				return action[_label]; 
			};
			Tab.prototype.keyChecker = function(_keyCode){
				console.group();
				console.log(`%cKey check: ${_keyCode}`, flowStyle);
				console.groupEnd();

				const action = Object.assign({
					// default keys;
					"40" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"39" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"38" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"37" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"36" : FIRST_TAB,
					"35" : LAST_TAB
				}, KeyMore);

				return action[`${_keyCode}`];
			};
			Tab.prototype.eventBinder = function([_action, _data]){
				console.group();
				console.log("%cEvent bind", flowStyle);
				console.log("bind event: ", _action);
				console.log("data: ", _data);
				console.log("this: ", this);

				let index = _data;
				const maxIndex = this.tabUnits.length - 1; // 6
				const minIndex = 0;

				switch(_action){
					case "CHOOSE" :
						index = index;
						break;
					case "FIRST" : 
						index = minIndex;
						break;
					case "LAST" : 
						index = maxIndex;
						break;
					case "PREV" : 
						index = minIndex >= index ? index : index - 1;
						break;
					case "NEXT" : 
						index = maxIndex < index ? index : index + 1;
						break;
					default : 
						return;
				}

				// component value update;
				this.beforeIndex = this.activeIndex;
				this.activeIndex = index;

				console.log(`Active index : %c${index}`, "color:red; font-size:16px; text-transform:uppercase;");
				console.log(`Index sync check : %c${this.activeIndex === index}`, "color:red; font-size:16px; text-transform:uppercase;")
				console.groupEnd();
				
				// view update;
				this.setPosition(index);
				// if(this.isAutomaticTab || _action === CHOOSE){
				// }else{
				// 	this.setFocus(index);
				// }
			};
			Tab.prototype.setFocus = function(_index){
				console.group();
				console.log("%cSet Focus: ", flowStyle);
				console.log("Go to: ", _index);
				console.log("this: ", this);				
				console.log("focus element [before]: ", document.activeElement);
				
				const roller = this.roller;
				const calculateAPI = this.calc;
				const distance = calculateAPI.scrollPosition.call(this, _index);
				
				this.tabUnits[_index].focus();	// diff between setPosition
				this.animate(roller, distance);

				console.log("focus element [after]: ", document.activeElement);
				console.groupEnd();
			};
			Tab.prototype.setPosition = function(_index){
				console.group();
				console.log("%cSet Position: ", flowStyle);
				console.log("Go to: ", _index);
				console.log("this: ", this);				
				console.log("focus element [before]: ", document.activeElement);

				const roller = this.roller;
				const calculateAPI = this.calc;
				const distance = calculateAPI.scrollPosition.call(this, _index);

				this.markActive(_index);	// diff between setPosition
				this.animate(roller, distance);

				console.log("focus element [after]: ", document.activeElement);
				console.groupEnd();
			};
			Tab.prototype.markActive = function(_index){
				
				console.group();
				console.log("%cMarking Active tab: ", flowStyle);
				console.log("this: ", this);
				console.log("this context index: ", this.activeIndex);
				console.log("param index: ", _index);
				console.log("use wai-aria:", this.webAccessibility);
				console.groupEnd();
				
				const index = _index || this.activeIndex;
				const tabUnits = this.tabUnits;
				const tabPanels = this.tabPanels;
				const activeClass = this.activeClass;
				const activeUnit = tabUnits[index];
				const activePanel = tabPanels[index];
				const useWA = this.webAccessibility;

				// set attribute
				tabUnits.forEach((unit, i) => {
					unit.tabIndex = -1;
					useWA ? unit.setAttribute("aria-selected", false) : unit.classList.remove(activeClass);
					if(index === i){
						unit.tabIndex = 0;
						useWA ? unit.setAttribute("aria-selected", true) : unit.classList.add(activeClass);
					}
				});
				
				tabPanels.forEach((panel, i) => {
					panel.classList.remove(activeClass);
					panel.tabIndex = -1;
					if(index === i){ 
						panel.classList.add(activeClass); 
						panel.tabIndex = 0;
					}
				});
			};
			Tab.prototype.animate = function(_roller = this.roller, _distance){
				console.group();
				console.log(`%cAnimate`, flowStyle);
				console.log("roller:", _roller);
			
				let distance = _distance;
				const [leftRange, rightRange] = this.boundRange;

				if( 0 <= distance && leftRange < distance){
					console.log("Heat right wall!!");
					distance = leftRange;
				};
				if( 0 > distance && rightRange > distance ) {
					console.log("Heat left wall!!");
					distance = rightRange;
				};
				
				console.log("distance:", _distance);
				console.groupEnd();

				_roller.style.transform = `matrix(1,0,0,1,${distance},0)`
			};
			// calculate
			Tab.prototype.calc = (function(){
				const API = {
					tabMargin : function(_index){
						console.group();
						console.log("%cCalc.margin: ", APIStyle);
						console.log("this:", this);
						
						const element = this.tabUnits[_index];
						console.log(element);
						const marginOneSide = parseInt( window.getComputedStyle(element, null).getPropertyValue("margin-left").replace("px", "") ); 

						console.log(marginOneSide);
						console.groupEnd();

						return marginOneSide;
					},
					scrollPosition : function(_index){
						console.group();
						console.log("%cCalc.position: ", APIStyle);
						// console.log("this:", this);
						
						const element = this.tabUnits[_index];
						const direction = this.direction ? 1 : -1;
						const position = (element.offsetLeft - this.calc.tabMargin.call(this, _index)) * direction;
						
						// console.dir(element);
						console.log(position);
						console.groupEnd();

						return position;
					},
					scrollContainerWidth : function(){
						const width = this.rootElement.querySelector(".scrollContainer").offsetWidth;
						console.log(`${this.rootElement.getAttribute("id")}'s' scroll-container width : %c${width}`, "color:#fff; font-size:13px; padding:3px 5px; background-color:#333;");
				
						return width;
					},
					scrollBeltWidth : function(){ 
						console.log("this", this);
						const scrollItem = this.rootElement.querySelectorAll("[role=tab]");
						const scrollItemMargin = this.calculate.tabMargin.call(this)
						const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
						const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

						if(debugFlag){
							console.group();
							console.log(scrollItem);
							console.log(`scrollItemMargin : ${scrollItemMargin}`);
							console.log(`baseWidth : ${scrollItemMargin}`);
							console.log(`totalWidth : ${totalWidth}`);
							console.groupEnd();
						}

						return totalWidth;
					},
					scrollBoundRange : function(_containerWidth){
						const leftRange = Math.floor( _containerWidth * 0 );
						const rightRange = Math.floor( ( _containerWidth - this.calculate.scrollBeltWidth.call(this) ) * 1 );
						
						if(debugFlag){
							console.group();
							console.log(`%cCalculate.scrollBoundRange`, "color:red;font-size:18px");
							console.log("this:", this);
							console.log(`leftRange : ${leftRange}`);
							console.log(`rightRange : ${rightRange}`);
							console.groupEnd();
						}

						return [leftRange, rightRange];
					}
				};
				return API;
			})();

			Tab.prototype.calculate = {
				scrollContainerWidth : ()=>{
					const width = this.rootElement.querySelector(".scrollContainer").offsetWidth;
					console.log(`${this.rootElement.getAttribute("id")}'s' scroll-container width : %c${width}`, "color:#fff; font-size:13px; padding:3px 5px; background-color:#333;");
			
					return width;
				},
				scrollBeltWidth : (_index = this.activeIndex)=>{ 
					const scrollItem = this.rootElement.querySelectorAll("[role=tab]");
					const scrollItemMargin = this.calc.tabMargin.call(this, _index);
					const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
					const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

					if(false){
						console.group();
						console.log(scrollItem);
						console.log(`scrollItemMargin : ${scrollItemMargin}`);
						console.log(`baseWidth : ${scrollItemMargin}`);
						console.log(`totalWidth : ${totalWidth}`);
						console.groupEnd();
					}

					return totalWidth;
				},
				scrollBoundRange : (containerWidth)=>{
					const leftRange = Math.floor( containerWidth * 0 );
					const rightRange = Math.floor( ( containerWidth - this.calculate.scrollBeltWidth() ) * 1 );
					
					if(false){
						console.group();
						console.log(`%cCalculate.scrollBoundRange`, "color:red;font-size:18px");
						console.log("this:", this);
						console.log(`leftRange : ${leftRange}`);
						console.log(`rightRange : ${rightRange}`);
						console.groupEnd();
					}

					return [leftRange, rightRange];
				}
			}
			Tab.prototype.init = function(){
				// console.log("proto : ", this);
				this.boundRange = this.calculate.scrollBoundRange( this.calculate.scrollContainerWidth() );
				// pre setting
				this.tabUnits.forEach( (unit, idx) => this.activeIndex === idx && ( this.webAccessibility ? (unit.setAttribute("aria-selected", true), unit.tabIndex = 0) : unit.tabIndex = 0 ) );
				this.tabPanels.forEach( (panel, idx) => this.activeIndex === idx && ( panel.tabIndex = 0 ) );
				this.tabEvent();
			};
			self.init();

			// const init = ()=>{

			// 	console.log(this);
			// 	self.init();
			// 	// this.init();

			// 	self.event();
			// };
			// Tab.prototype.init();
		}
		
		const tenKey = {
			"104" : "PREV",
			"100" : "PREV",
			"102" : "NEXT",
			"98" : "NEXT",
			"103" : "FIRST",
			"97" : "LAST"
		}

		const tab = document.querySelectorAll("[role=tablist]");

		const tablist1 = new Tab({
			rootElement : tab[0],
			webAccessibility : true,
			addBindKeys : tenKey,
			focusWithPosition : "manual"
		});

		const tablist2 = new Tab({
			rootElement : tab[1],
			focusWithPosition : "automatic",
			direction : "rtl"
		});
		
	</script>
	<!-- <script>
		const TabScroller = (function(){
			function TabScroller(root){
				this.root = root;
				this.tabButton = this.root.querySelectorAll("[role=tab]") || this.root.querySelectorAll(".tab");
				TabScroller.prototype.event = function(){
					console.log(this.tabButton);
					this.tabButton.forEach( tab => tab.addEventListener("click", function(event){
						console.log("event:click");
						const siblings = this.parentElement.children;
						const index = Array.prototype.findIndex.call(siblings, sibling => sibling === this);
						TabScroller.prototype.markActive(index);
					}))
				};
				TabScroller.prototype.markActive = function(index){
					console.log(this);
					console.log(TabScroller);
					console.log(index);
					console.log(TabScroller.tabButton[index]);
				}
			}
			return TabScroller;
		})();
		const Tab = document.querySelectorAll("[role=tablist]");
		const tabList1 = new TabScroller(Tab[0]);
		const tabList2 = new TabScroller(Tab[1]);
		console.log(tabList1);
		console.log(tabList2);
		tabList1.event();
		tabList2.event();
	</script> -->
	<!-- <script>
		'use district';
		const tabUI = document.querySelectorAll("[role=tablist]");
		const initialConfig = [
			// tabList1
			{
				rootElement : tabUI[0],
				activeIndex : 3,
				webAccessibility : true
			},
			// tabLis2
			{
				rootElement : tabUI[1],
				tabSelector : ".tab",
				activeIndex : 0
			}
		];
		
		const tabList = initialConfig.reduce((acc, config, idx)=>{
			config.rootElement = tabUI[idx];
			acc[idx] = new Tab(config);
			return acc;
		},[]);
		// console.log(tabList);

		function Tab(config){
			this.rootElement = config.rootElement;
			this.tabUnits = config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(`${config.tabSelector}`);
			this.activeIndex = config.activeIndex || 0;
			this.activeClass = config.activeClass || "active";

			const isWA = this.webAccessibility = config.webAccessibility || false;
			const activeTabUnit = this.tabUnits[this.activeIndex];
			const scroller = this.rootElement.querySelector(".scroller");
			const activeClass = `${this.activeClass}`;

			// P = Tab.prototype;
			A = Array.prototype;

			Tab.prototype.init = ()=>{
				console.log(this);

				// tab event
				this.tab();
			};
		
			
			const clickEvent = (event, _this)=>{
				// markActive
				const siblings = unit.parentElement.children;
				A.forEach.call(siblings, sibling => {
					sibling.classList.remove(activeClass);
					if(isWA) sibling.setAttribute("aria-selected", false);
				});
				unit.classList.add(activeClass);
				if(isWA) unit.setAttribute("aria-selected", true);
			}
			const pressedEvent = (event)=>{
				console.log(event);
			}
			const tabEvent = (event)=>{
				console.log(event);
				switch(event.type){
					case "click" : clickEvent(event); break;
					case "keyup" : pressedEvent(event); break;
				}
			}
			Tab.prototype.tab = function(){
				this.tabUnits.forEach((unit, index)=>{
					unit.addEventListener("click", tabEvent);
				});
			};

			this.tabEvent = {
				handleEvent : (event)=>{
					console.log(event);
					console.log(this);
					event.preventDefault();
					switch(event.type){
						case "click" : tabEvent.byClick(event); break;
						case "keyup" : tabEvent.byPressed(event); break;
					}
				},
				byClick : (event)=>{

				},
				byPressed : (event)=>{

				}
			}
			// Tab.prototype.getPositionIndex = function(_self){
			// 	const siblings = _this.parentElement.children;
			// 	this.activeIndex = A.findIndex.call(siblings, element => element === _self);
			// 	console.log(`Active index : ${this.activeIndex}`);		
			// };
			// Tab.prototype.markActive = function(index){
			// 	// console.log(this.activeIndex);
			// 	// console.log(this.tabUnits);
			// 	this.tabUnits[index].classList.add(`${this.activeClass}`);
				
			// 	if(isWA){
			// 		this.tabUnits[index].setAttribute("aria-selected", "true");
			// 	}
			// };
			// Tab.prototype.animate = function(target = scroller, distance){
			// 	// console.log(target);
			// 	// console.log(distance);
			// 	target.style.transform = `matrix(1,0,0,1,${distance},0)`
			// };
			Tab.prototype.init();

		}
	</script> -->
	<!-- <script>
		// scenario
		/*
			dom을 탐색하여 tablist 요소를 선택한다
			선택한 요소의 dom tree를 확인하다
				- ul/ol이 쓰였을 때 :
				- role=tablist와 role=tab이 직접적인 부모 자식이었을 때 :
				- role=tab이 role=tablist의 자손이었을 때 :
			
		*/
		const tabUI = document.querySelectorAll("[role=tablist]");
		// console.log(tabUI);

		// constructor
		function Tab(config){
			// destructuring config object
			const {rootElement, scrollingSelector, initialPosition, direction, useWA, callbacks, debug, tab, customizing} = config;
			const {startIndex} = tab;
			if(customizing){
				const {addBindKeys} = customizing.options;
			}
			// pre-setting 
			this.rootElement = rootElement;
			this.direction = direction ? -1 : 1;
			this.useWA = useWA;
			this.scrollingSelector = scrollingSelector
			this.scrollBoundRange = null;
			if(debug){
				this.debug = {
					calculate : false || debug.calculate
				};
			}

			// prototype filed
			const p = Tab.prototype;
			// common methods
			// CRUD
			p.create = ()=>{
				this.init();
			};
			p.read = (request)=>{
				console.log(this);
				return eval(`this.${request}`);
			};
			p.update = ()=>{
				console.log(update);
			};
			p.delete = ()=>{
				this.init = null;
			};
			p.init = ()=>{
				// All null value are initialize
				this.scrollBoundRange = this.calculate.scrollBoundRange(this.calculate.scrollContainerWidth(this.debug.calculate), this.debug.calculate);

				// Call API
				// this.scrollLifeCycleAPI();
				
				// tab
				this.tab();

				// method chaining base
				return p;
			}

			// tab event
			this.tabUnit = this.rootElement.querySelectorAll("[role=tab]");
			this.tabPanelUnit = this.rootElement.querySelectorAll("[roll=tabpanel]");
			this.PrevArrow = this.rootElement.querySelector("[aria-label='Previous tab']");
			this.NextArrow = this.rootElement.querySelector("[aria-label='Next tab']");
			this.activeIndex = startIndex || 0;
			// console.log(
			// 	this.PrevArrow,
			// 	this.NextArrow
			// )
			p.tab = ()=>{
				Array.prototype.map.call(this.tabUnit, (unit)=>{
					unit.addEventListener("click", (event)=>{
						console.log("click");
						// console.dir(event.currentTarget);
						// console.dir(event.target);
						event.preventDefault();
						const _this = event.target;
						p.getIndex(_this);
						p.setPositionByIndex(this.activeIndex, this.scroller);
						// const role = _this.TagName;
						// if(_this.getAttribute("role") === "tab"){
						// 	console.log("button:tab");
						// }
						// if(_this.getAttribute("aria-label") === "Previous tab"){
						// 	console.log("button:prev");
						// }
						// if(_this.getAttribute("aria-label") === "Next tab"){
						// 	console.log("button:next");
						// }
					});
				});

				this.rootElement.addEventListener("keyup", ({keyCode})=>{
					// console.dir(event.currentTarget);
					// console.dir(event.target);
					// console.dir(event);
					// console.log(keyCode);
					// event.preventDefault();

					const action = {
						NEXT_TAB : "NEXT",
						PREV_TAB : "PREV",
						FIRST_TAB : "FIRST",
						LAST_TAB : "LAST"
					}
					const {NEXT_TAB, PREV_TAB, FIRST_TAB, LAST_TAB} = action;
					const bindKeys = Object.assign({
						// case:ten key less 
						"40" : NEXT_TAB,
						"39" : NEXT_TAB,
						"38" : PREV_TAB,
						"37" : PREV_TAB,
						"36" : FIRST_TAB,
						"35" : LAST_TAB
					}, addBindKeys);
					// console.log(bindKeys);
					p.loadPosition(bindKeys[`${keyCode}`]);
					
				});
				return p;
			}
			p.loadPosition = (action)=>{
				switch(action){
					case "NEXT" : 
						console.log(action.NEXT_TAB);
						this.activeIndex = (this.tabUnit.length <= this.activeIndex + 1) ? this.activeIndex : this.activeIndex + 1;
						p.setPositionByIndex(this.activeIndex);
						break;
					case "PREV" : 
						console.log(action.PREV_TAB); 
						this.activeIndex = (0 > this.activeIndex - 1) ? this.activeIndex : this.activeIndex - 1;
						p.setPositionByIndex(this.activeIndex);
						break;
					case "FIRST" : 
						console.log(action.FIRST_TAB);
						p.setPositionByIndex(0);
						break;
					case "LAST" : 
						console.log(action.LAST_TAB); 
						p.setPositionByIndex(this.tabUnit.length);
						break;
					default : break;
				}
			}
			p.getIndex = (_this)=>{
				const _siblings = _this.parentElement.children;
				this.activeIndex = Array.prototype.findIndex.call(_siblings, (element)=> element === _this);
				console.log(`Active index : ${this.activeIndex}`);

				return p;
			}
			this.isAutoPositioning = true;
			p.setPositionByIndex = (index)=>{
				console.log(index);
				const chosenElement = this.tabUnit[index];
				console.dir();
				if(this.isAutoPositioning){
					const scrollItemMargin = parseInt(window.getComputedStyle(chosenElement, null).getPropertyValue("margin-left").replace("px", ""));
					const distance = (chosenElement.offsetLeft - scrollItemMargin) * -1;

					// console.log(distance, chosenElement.offsetLeft, scrollItemMargin);
					
					p.scrollAnimate(distance);
				}else{

				}
				return p;
			}

			// calculate methods
			p.calculate = {
				scrollContainerWidth : (debugFlag)=>{
					const width = this.rootElement.querySelector(".scrollContainer").offsetWidth;

					if(debugFlag){
						console.log(width);
					}
					
					return width;
				},
				scrollBeltWidth : (debugFlag)=>{ 
					const scrollItem = this.rootElement.querySelectorAll("[role=tab]");
					const scrollItemMargin = parseInt(window.getComputedStyle(scrollItem[0], null).getPropertyValue("margin-left").replace("px", ""));
					const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
					const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

					if(debugFlag){
						console.group();
						console.log(`scrollItem : ${scrollItem}`);
						console.log(`scrollItemMargin : ${scrollItemMargin}`);
						console.log(`baseWidth : ${scrollItemMargin}`);
						console.log(`totalWidth : ${scrollItemMargin}`);
						console.groupEnd();
					}

					return totalWidth;
				},
				scrollBoundRange : (containerWidth, debugFlag)=>{
					const leftRange = Math.floor( containerWidth * 0 );
					const rightRange = Math.floor( ( containerWidth - p.calculate.scrollBeltWidth(this.debug.calculate) ) * 1 );

					if(debugFlag){
						console.log(`leftRange : ${leftRange}`);
						console.log(`rightRange : ${rightRange}`);
					}

					return [leftRange, rightRange];
				}
			}
			/*
				scroll event lifecycle
				action => create => render => action => [update] => render
				action => create => render => action => [delete] => render(remove on view)
				
				- controller
				1. controller(user action, handlers:[START, MOVE, END], options, target:rootElement);
					- user action의 type에 따라 handler를 선택하며, 각기 수행한 이벤트의 정보를 반환한다.
						# createEvent(handlers:START[, options]) return event data
						# updateView(handlers:MOVE, options) return event data
						# deleteEvent(handlers:END) return event data
				- model
				1. model(event data) return data for render;
					- 이벤트 정보를 받아 view를 렌더링하기 위한 정보를 생성/가공한다.

				- render
				1. render(renderer, data:[calculate value, model])
					- 모델로부터 정보를 받아 view를 만든다.
				

				user action => scroll Event Triggered => mouse/touch point move => view re-action => user action stop/end => re-rendering n correction
				마우스 다운 => 스크롤 이벤트 등록 => 마우스 좌표 기반 계산값을 요소에 반영 => css transition => 마우스 업 => 요소 위치 결정 및 보정 (direction, over scroll....);
			*/
			p.scrollLifeCycle = (
				userAction = {
					"START" : ["touchstart", "mousedown"],
					"MOVE" : ["touchmove", "mousemove"],
					"END" : ["touchend", "mouseup"]
				}, 
				handlers, 
				options, 
				target = this.rootElement
			)=>{
				// controller
				let eventData = null;
				return ()=>{
					const API = this.scrollLifeCycleAPI;
					switch(userAction){
						case "START" :
							eventData = API.createEvent(userAction, handlers["START"], target, options = false);
							break;
						case "MOVE" :
							eventData = API.updateView(userAction, handlers["MOVE"], options);
							break;
						case "END" : 
							eventData = API.deleteEvent(userAction, handlers["END"]);
							break;
						default : 
							throw new Error("This is not defined action.(정의된 동작이 아닙니다)");
					}
				}
			}
			p.scrollLifeCycleAPIs = {
				initialized : (beforePosition) => {
					const element = this.rootElement.querySelector(`${this.scrollingSelector}`);
					this.scrollLifeCycleAPIs.render(element, beforePosition);
				},
				createEvent : (action, handler, target, options)=>{
					target.addEventListener(action, handler(options));
				},
				updateView : ()=>{

				},
				deleteEvent : ()=>{

				},
				modeling : ()=>{

				},
				render : (scroller, distance)=>{
					scroller.style.transform = `matrix(1, 0, 0, 1, ${distance}, 0)`;
				}
			}
			this.initialPosition = initialPosition || 0;
			this.scrollPosition = null;
			console.log(this.rootElement);
			this.scroller = this.rootElement.querySelector(`${this.scrollingSelector}`);
			const addTransition = (time = 300)=>{
				const tg = this.rootElement.querySelector(`${this.scrollingSelector}`);
				tg.setAttribute("style", `transition:transform ${time}ms ease`);
				setTimeout(()=>{
					tg.style.transition = "";
				}, 400);

				return true;
			};

			p.scrollAnimate = (distance, element = this.scroller)=>{
				console.log(element);
				element.style.transform = `matrix(1, 0, 0, 1, ${distance}, 0)`;
			}
			p.scrollLifeCycleAPI= ()=>{
				const target = this.rootElement;
				const START = "mousedown";
				const END = "mouseup";
				const MOVE = "mousemove";
				const touchPosition = {
					x : null,
					distance_x : 0,
					startPoint : null,
				};

				const callback = (triggerEvent)=>{
					const {currentTarget} = triggerEvent;
					const element = currentTarget.querySelector(`${this.scrollingSelector}`);
					console.log(currentTarget);
					console.log(element);
					touchPosition.x = triggerEvent.touches ? triggerEvent.touches[0].screenX : triggerEvent.screenX;
					touchPosition.startPoint = this.scrollPosition;

					return (moveEvent)=>{
						const movePosX = moveEvent.touches ? moveEvent.touches[0].screenX : moveEvent.screenX;
						const distance = movePosX - touchPosition.x;

						this.scrollPosition = touchPosition.startPoint + distance;
						p.scrollAnimate(this.scrollPosition, element);
					};
				};
				// switch
				console.log(target)
				target.addEventListener(START, (event)=>{
					const handler = callback(event);
					window.addEventListener(MOVE, handler, false);
					window.addEventListener(END, ()=>{
						window.removeEventListener(MOVE, handler, false);
						// const [leftRange, rightRange] = this.scrollBoundRange;
						// if(0 <= this.scrollPosition && leftRange < this.scrollPosition && addTransition()) this.scrollPosition = leftRange;
						// if(0 > this.scrollPosition && rightRange > this.scrollPosition && addTransition()) this.scrollPosition = rightRange;
						p.scrollAnimate(this.scrollPosition, this.scroller);
					}, false);
				}, false);
			}

			// web accessible methods
			if(useWA){
				p.accessibility = ()=>{
					console.log("ref wcag");
				}
			}
		}

		// useage
		const tabList = new Tab({
			rootElement : tabUI[0],
			scrollingSelector : ".scroller",
			direction : 1,
			initialPosition : -100,
			useWA : false,
			debug : {
				flag : false,
				calculate : false,
			},
			tab : {
				startIndex : 0,
			},
			customizing : {
				flag : true,
				options : {
					// ten key
					addBindKeys : {
						"104" : "PREV",
						"100" : "PREV",
						"102" : "NEXT",
						"98" : "NEXT",
						"103" : "FIRST",
						"97" : "LAST"
					},
				}
			}
		});
		tabList.create();
		console.log(tabList);
		// const approachConfig = tabList.read("calculate");
		// console.log(approachConfig);
		// tabList.delete();
		// console.log(tabList.init);

		const tabList2 = new Tab({
			rootElement : tabUI[1],
			scrollingSelector : ".scroller",
			direction : 1,
			initialPosition : -100,
			useWA : false,
			debug : {
				flag : false,
				calculate : false,
			},
			tab : {
				startIndex : 0,
			},
			customizing : {
				flag : true,
				options : {
					// ten key
					addBindKeys : {
						"104" : "PREV",
						"100" : "PREV",
						"102" : "NEXT",
						"98" : "NEXT",
						"103" : "FIRST",
						"97" : "LAST"
					},
				}
			}
		});
		console.log(tabList2);
	</script> -->
	<!-- <script>
		const start = document.getElementById("tab");
		function find(el){
			let findTg = null;
			let treeNestedDepth = 0;
			
			const findTgElement = ()=>{
				if (
					el.children[0].attributes.getNamedItem("role") !== null && 
					el.children[0].attributes.getNamedItem("role").value === "tab"
				){
					findTg = el.children;
					return findTg, treeNestedDepth;
				}else{
					let rebind = el.children[0];
					treeNestedDepth++;
					find.call(document, rebind);
				}
			}
			findTgElement();
		};
		function uiElementChecker(tgElements){
			console.log(tgElements);
			Array.map.call(tgElements, (el)=>{
				console.dir(el);
				el.tabIndex !== 0 && el.setAttribute("tabindex", 1);
			});
		};
		// scenario
		/*
		role=tablist를 root element로 하는 dom tree를 생성 또는 인지.
		screen fit에 맞춰 리사이징.
		한줄 정렬 시 스크롤 ui 제공.
		현재 탭의 위치 표시 및 index 리턴. by mouse, keyboard, touch, scroll.
		arrow, wheel로 스크롤 이동 시 
		index를 이용한 callback 사용 제공.
		index를 이용한 history stack 생성. 
		라이프 사이클 api 제공.
		커스텀 함수를 추가하여 확장가능하도록 최소 기능으로 한정.
		console.log를 통해 wai-aria의 맞지 않거나 미진한 부분을 작성자에게 전달.
		이후 carousel 케이스 추가.
		*/
		function interaction(eventObject, dispatch){
			const object = eventObject || {};
			if( 0 <= eventObject.type.indexOf("key")){
				object.type = "keyboardEvent"; 
			}
			return object;
		}

		function TabUI([
			root,
			direction,
			mediaMatches
		]){
			this.root = document.querySelectorAll(root);
			this.componentRoot =  this.root.forEach((el)=>{return el});
			this.direction = direction,
			this.mediaQuery = mediaMatches
			;
			const init = ()=>{
				focusable();
			}
			// static field
			const accessibilityError = (flag)=>{
				if(flag === false || flag === undefined) return flag;

				console.group();
				if(this.root.children().getAttribute("role") === tab && this.root.children().getAttribute("aria-labelledBy") === undefined ){
					console.log("accessible name을 지정해주세요.");
				}
				console.groupEnd();
			};
			const focusable = ()=>{
				console.log("focusable");
				console.log(this.componentRoot);
				document.querySelectorAll(root + " [role=tab]").forEach((children)=>{
					if(children.tabIndex !== 1) children.tabIndex = 1; 
				});
			};
			// 
			const interface = TabUI.prototype; 
			interface.positioning = (pos)=>{

			};
			interface.addEventListener = (eventType, callback)=>{
				return window.addEventListener.call(this.root[0], eventType, (eventObject) => {
					callback();
				});
			}
			interface.keyEvent = (callback)=>{
				window.addEventListener.call(this.root[0], "keydown", (event)=>{
					console.log(event);

					const actionType = interaction(event);
					console.log(actionType);
					if(event.__proto__.initKeyboardEvent){
						console.log(event.keyCode);
					}
				})
			}
			init();
		}
		const tab1 = new TabUI([
			"#tab",	// root
			"ltr",
			768
		]);
		tab1.keyEvent()
	</script> -->
</body>
</html>