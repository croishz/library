<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		body {margin:0;}
		[dir="rtl"] {direction:rtl;}
		[role="tablist"] {margin-top:20px;}
		[role="tablist"] > .scrollContainer {
			overflow: hidden;
			/* overflow-y: unset;
			overflow-x: scroll; */
			border:1px solid #000;
			box-sizing: border-box;
		}
		[role="tablist"] .scroller {
			display:flex;
			margin:0 -6px;
			will-change:contents;
			transition: transform 400ms ease;
		}
		[role="tablist"] .scroller.test {
			transition: none;
		}
		[role="tablist"] .scroller.align-center {
			justify-content: center;
		}
		[role="tablist"] [role="tab"] {padding:14px 20px; margin:0 6px; cursor: pointer; text-align:center;}
		[role="tablist"] [role="tab"]:nth-child(odd) {background-color:gold; flex-basis:140px; min-width:140px;}
		[role="tablist"] [role="tab"]:nth-child(even) {background-color:tan; flex-basis:auto;}
		[role="tablist"] [role="tab"][aria-selected="true"],
		[role="tablist"] [role="tab"].active,
		[role="tabpanel"].active {background-color:lightcoral; color:#fff;}
		/* ui elements */
		[role="tablist"] button {border:none; padding:0; margin:0; font:1rem inherit inherit;}
		[role="tablist"] .indicator button {padding:4px 10px; cursor: pointer;}

		/* sample variation */
		#tab1 .scrollContainer {
			width:45%;
			max-width:500px;
			min-width:320px;
		}
	</style>
</head>
<body>
	<div id="tab1" role="tablist" data-rootName="tablist1" aria-label="tab ui sample">
		<div class="scrollContainer">
			<div class="scroller">
				<button type="button" id="tab01" role="tab" aria-controls="tab1_panel01" aria-selected="false">tab01</button>
				<button type="button" id="tab02" role="tab" aria-controls="tab1_panel02" aria-selected="false" tabindex="-1">tab02</button>
				<button type="button" id="tab03" role="tab" aria-controls="tab1_panel03" aria-selected="false" tabindex="-1">tab03</button>
				<button type="button" id="tab04" role="tab" aria-controls="tab1_panel04" aria-selected="false" tabindex="-1">tab04</button>
				<button type="button" id="tab05" role="tab" aria-controls="tab1_panel05" aria-selected="false" tabindex="-1">tab05</button>
				<button type="button" id="tab06" role="tab" aria-controls="tab1_panel06" aria-selected="false" tabindex="-1">tab06</button>
				<button type="button" id="tab07" role="tab" aria-controls="tab1_panel07" aria-selected="false" tabindex="-1">tab07</button>
			</div>
		</div>
		<div class="indicator" aria-controls="tab1">
			<button type="button" aria-disabled="true" tabindex="-1" aria-label="Previous tab">Prev</button>
			<button type="button" aria-disabled="true" tabindex="-1" aria-label="Next tab">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul id="tab1_panels" role="none">
		<li id="tab1_panel01" role="tabpanel" aria-labelledby="tab01">Panel-01</li>
		<li id="tab1_panel02" role="tabpanel" aria-labelledby="tab02">Panel-02</li>
		<li id="tab1_panel03" role="tabpanel" aria-labelledby="tab03">Panel-03</li>
		<li id="tab1_panel04" role="tabpanel" aria-labelledby="tab04">Panel-04</li>
		<li id="tab1_panel05" role="tabpanel" aria-labelledby="tab05">Panel-05</li>
		<li id="tab1_panel06" role="tabpanel" aria-labelledby="tab06">Panel-06</li>
		<li id="tab1_panel07" role="tabpanel" aria-labelledby="tab07">Panel-07</li>
	</ul>
	<!-- // #tab1 -->
	
	<div id="tab2" role="tablist" dir="rtl">
		<div class="scrollContainer">
			<div class="scroller align-center">
				<div role="tab" class="tab">tab01</div>
				<div role="tab" class="tab">tab02</div>
				<div role="tab" class="tab">tab03</div>
				<div role="tab" class="tab">tab04</div>
				<div role="tab" class="tab">tab05</div>
				<div role="tab" class="tab">tab06</div>
				<div role="tab" class="tab">tab07</div>
			</div>
		</div>
		<div class="indicator">
			<button type="button">Prev</button>
			<button type="button">Next</button>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul role="none">
		<li role="tabpanel">Panel-01</li>
		<li role="tabpanel">Panel-02</li>
		<li role="tabpanel">Panel-03</li>
		<li role="tabpanel">Panel-04</li>
	</ul>
	<!-- // #tab2 -->

	<div class="tab4" role="tablist" dir="rtl">
		<div class="scrollContainer">
			<div class="scroller">
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
				<div role="tab" class="tab"></div>
			</div>
		</div>
	</div>
	<!-- if native HTML, declare role=none -->
	<ul role="none">
		<li role="tabpanel"></li>
		<li role="tabpanel"></li>
		<li role="tabpanel"></li>
		<li role="tabpanel"></li>
	</ul>
	<!-- // .tab4 -->
	<script>
		function Tab(config){
			/* Constructor value */
			this.name = config.rootElement.getAttribute("data-rootname") || config.rootElement.getAttribute("id") || config.rootElement.getAttribute("class");
			this.activeClass = config.activeClassOnTab || "active";
			this.activeIndex = config.startIndex || 0;
			this.beforeIndex = this.activeIndex;
			this.addBindKeys = config.addBindKeys || {};
			this.indicatorUseage = config.indicatorUseage || "scroll";
			this.debounceDuration = config.debounceDuration || 400;
			this.template = new String("html") || false;
			this.DefaultFetchURL = config.fetchURL || "/";
			
			// DOM
			this.rootElement = config.rootElement;
			this.tabUnits = config.rootElement.querySelectorAll("[role=tab]") || config.rootElement.querySelectorAll(".tab");
			this.tabPanelWrap = config.panelWarpElement || document.querySelector(`${config.rootElement.getAttribute("id")}_panels`) || config.rootElement.nextElementSibling;
			this.tabPanels = Array.prototype.map.call(this.tabPanelWrap.children, child => child);
			this.rollerContainerSelector = config.rollerContainerSelector || ".scrollContainer";
			this.rollerContainer = this.rootElement.querySelector(`${this.rollerContainerSelector}`);
			this.rollerSelector = config.rollerSelector || ".scroller";
			this.roller = this.rootElement.querySelector(`${this.rollerSelector}`);
			this.indicatorSelector = config.indicatorSelector || ".indicator";
			this.indicator = config.indicator || config.rootElement.querySelector(`${this.indicatorSelector}`);
			this.arrows = this.indicator && Array.prototype.map.call(this.indicator.children, child => child);
			
			// Initialize value
			this.swipeHandleEvent = null;
			this.containerWidth = null;
			this.scrollRange = null;
			this.position = {
				newPoint : null,
				startPoint : null,
				nowPoint : null
			};

			// Flag
			this.webAccessibility = config.webAccessibility || false;
			this.isAutomaticTab = config.focusWithPosition === "automatic" ? true : false; 
			this.isRTL = config.direction === "rtl" ? true : false;
			this.debug = config.debug || false;

			// Action type
			const NEXT_TAB = "NEXT";
			const PREV_TAB = "PREV";
			const FIRST_TAB = "FIRST";
			const LAST_TAB = "LAST";
			const CHOOSE = "CHOOSE";
			const SWIPE_START = "SWIPE_START";
			const SWIPE_MOVE = "SWIPE_MOVE";
			const SWIPE_END = "SWIPE_END";
			const STEADY = "STEADY";
			
			// Log style
			const flowStyle = "color:#49b777; font-size:15px; background-color:#f9f9f9; padding:4px 8px; border:1px solid tan;";
			const APIStyle = "color:lightcoral; font-size:14px; font-weight:600; text-decoration:underline; font-style:italic;"
			const scrollHandler = "color:lightcoral";
			
			/* Prototype method */
			// Flow
			Tab.prototype.fetch = function(
				_callback,
				_url = this.DefaultFetchURL,
				_dataType = "json", 
				_action = "get"
			){
				console.group();
				console.log("%cFetch", flowStyle);
				console.log(`action: ${_action}`);
				console.log(`data type: ${_dataType}`);
				console.log(`url: ${_url}`);

				const xhr = new XMLHttpRequest();
				const callback = _callback.bind(this);

				xhr.responseType = _dataType;
				xhr.onreadystatechange = function(){
					// console.log("xhr: ", this);
					// console.log(context.name);
					if(this.readyState === this.DONE && this.status === 200){
						const response = xhr.response;
						callback(response);
						console.groupEnd();
					}else{
						console.log(`Error code: ${xhr.status}`);
						console.groupEnd();
					}
				}
				xhr.open(_action, _url, true);
				xhr.send();
			};
			Tab.prototype.fetchCallback = function(_response){
				const data = _response.product;
				
				console.group();
				console.log(this);
				console.log(data);
				
				data.map((contents, idx)=>{
					this.tabUnits[idx] && (this.tabUnits[idx].innerText = contents.id);
					this.tabPanels[idx] && (this.tabPanels[idx].innerText = contents.copy);
				});

				console.groupEnd();
			};
			Tab.prototype.dispatch = function(action, data){
				if(this.debug){
					console.group();
					console.log("%cDispatch", flowStyle)
					console.log("action:", action);
					console.log("data:", data);
					console.groupEnd();
				}
				// something do this
				
				return [action, data];
			}
			Tab.prototype.eventBinder = function([_action, _data]){
				if(this.debug){
					console.group();
					console.log("%cEvent bind", flowStyle);
					console.log("bind event: ", _action);
					console.log("data: ", _data);
					console.log("this: ", this);
				}

				// bind dependency
				let dep = null;
				const depType = {
					INDEX : "INDEX",
					SCREEN_POSITION : "SCREEN_POSITION",
				}

				// variable for INDEX;
				const maxIndex = this.tabUnits.length - 1; // 6
				const minIndex = 0;
				let index = (_data.index === null || _data.index === undefined) ? this.activeIndex : _data.index;
				
				// variable for SCREEN_POSITION;
				const screenX = (_data.screenX === null || _data.index !== undefined) ? this.positionX : _data.screenX;
				// const direction = this.isRTL ? 1 : -1;
				const direction = -1;

				switch(_action){
					case "CHOOSE" :
						dep = depType.INDEX;
						index = index;
						config.dynamicFetch && this.fetch(this.fetchCallback);
						break;
					case "FIRST" : 
						dep = depType.INDEX;
						index = minIndex;
						break;
					case "LAST" : 
						dep = depType.INDEX;
						index = maxIndex;
						break;
					case "PREV" : 
						dep = depType.INDEX;
						index = minIndex >= index ? minIndex : index - 1;
						break;
					case "NEXT" : 
						dep = depType.INDEX;
						index = maxIndex <= index ? maxIndex : index + 1;
						break;
					case "SWIPE_START" : 
						dep = depType.SCREEN_POSITION;
						this.roller.classList.add("test");

						// this.roller.parentElement.addEventListener("mousedown", this.swipeHandleEvent, false);
						window.addEventListener("mousemove", this.swipeHandleEvent, false);
						window.addEventListener("mouseup", this.swipeHandleEvent, false);
						
						// this.roller.parentElement.addEventListener("touchstart", this.swipeHandleEvent, false);
						// window.addEventListener("touchmove", this.swipeHandleEvent, false);
						// window.addEventListener("touchEnd", this.swipeHandleEvent, false);

						this.position.newPoint = screenX;
						this.position.startPoint = this.position.nowPoint;
						
						if(this.debug){
							console.group();
							console.log("swipe start point: ", this.position.newPoint);
							console.groupEnd();
						}
						break;
					case "SWIPE_END" : 
						dep = depType.SCREEN_POSITION;
						this.roller.classList.remove("test");

						// this.roller.parentElement.removeEventListener("mousedown", this.swipeHandleEvent, false);
						window.removeEventListener("mousemove", this.swipeHandleEvent, false);
						window.removeEventListener("mouseup", this.swipeHandleEvent, false);

						// this.roller.parentElement.removeEventListener("touchstart", this.swipeHandleEvent, false);
						// window.removeEventListener("touchmove", this.swipeHandleEvent, false);
						// window.removeEventListener("touchEnd", this.swipeHandleEvent, false);

						if(this.debug){
							console.log(this.position.newPoint);
							console.log(screenX);						
							console.log(SWIPE_END);
						}

						if(this.position.newPoint !== screenX) {
							console.log("did to swipe");
							// this.position.nowPoint = this.animate(this.wallHeat(this.position.nowPoint));
							this.position.nowPoint = this.animate(this.position.nowPoint);
						};
						break;
					case "SWIPE_MOVE" : 
						dep = depType.SCREEN_POSITION;
						const distance = (screenX - this.position.newPoint) * direction;
						this.position.nowPoint = this.position.startPoint - distance;
						this.animate(this.position.nowPoint, true);

						if(this.debug){
							console.group();
							console.log("this.position.startPoint:", this.position.startPoint);
							console.log("distance: ", distance);
							console.log("mouse point: ", this.position.nowPoint);
							console.groupEnd();
						}
						break;
					case "STEADY" :
					default : 
						console.log("%cFlow end!", "font-size:24px;");
						console.groupEnd();
						return;
				}

				if(dep === depType.INDEX){
					// component value update;
					this.beforeIndex = this.activeIndex;
					this.activeIndex = index;
					
					const viewFlag = (this.isAutomaticTab || _action === CHOOSE) ? true : false;
					const roller = this.roller;
					const distance = this.calculateAPI.scrollPosition.call(this, index);
					
					if(this.debug){
						console.log("%cUI update", flowStyle);
						console.log("index: ", index);
						console.log("view flag: ", viewFlag);
						console.log("focus element [before]: ", document.activeElement);
					}
					// view update;
					if(viewFlag){
						this.markActive(index);
						this.setFocus(index);
					}else{
						this.setFocus(index);
					}

					// this.position.nowPoint = this.animate(this.wallHeat(distance));
					this.position.nowPoint = this.animate(distance);
					
					if(this.debug){
						console.log("focus element [after]: ", document.activeElement);
						console.log(`Active index : %c${this.activeIndex}`, "color:red; font-size:16px; text-transform:uppercase;");
						console.log(`Index sync check : %c${this.activeIndex === this.index}`, "color:red; font-size:16px; text-transform:uppercase;");
					}
				}

				if(this.debug){
					console.log("%cFlow end!", "font-size:24px;");
					console.groupEnd();
				}

				return this;
			};
			// animate
			Tab.prototype.animate = function(_distance, _moveflag = false, _roller = this.roller){
				// const distance = _distance;
				const distance = _moveflag ? _distance : this.wallHeat(_distance);

				if(this.debug){
					console.group();
					console.log("%cAnimate", flowStyle);
					console.log("roller:", _roller);
					console.log("distance:", _distance);
					console.groupEnd();
				}
				
				_roller.style.transform = `matrix(1,0,0,1,${distance},0)`

				return distance;
			};
			Tab.prototype.wallHeat = function(_distance){
				if(true){
					console.group();
					console.log(_distance);
					console.groupEnd();
				}

				let distance = _distance;
				const [leftLimit, rightLimit] = this.scrollRange;

				if( 0 <= distance && leftLimit < distance){
					true && console.log("Heat right wall!!");
					distance = leftLimit;
				};
				if( 0 > distance && rightLimit > distance ) {
					true && console.log("Heat left wall!!");
					distance = rightLimit;
				};

				return distance;
			};
			// tab event
			Tab.prototype.tabEvent = function(){
				// tab button
				if(this.tabUnits){
					this.tabUnits.forEach(
						unit => {
							// by click
							unit.addEventListener("click", ({type, currentTarget})=>{
								if(this.debug){
									console.group();
									console.log(`%cEvent: ${type}`, flowStyle);
									console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", currentTarget === unit);
									console.groupEnd();
								}
								
								const action = event.type === "click" && CHOOSE;
								const index = {index : this.getIndex(unit)};
								action && this.eventBinder( this.dispatch(action, index) );

								return false;
							});
							// by keyup
							unit.addEventListener("keyup", ({type, currentTarget, keyCode})=>{
								if(this.debug){
									console.group();
									console.log(`%cEvent: ${type} / ${keyCode}`, flowStyle);
									// console.log("this: ", this);
									console.log("unit: ", unit);
									console.log("Matched event.target: ", currentTarget === unit);
									console.groupEnd();
								}

								const action = this.keyChecker(keyCode);
								const index = {index : this.activeIndex};
								action && this.eventBinder( this.dispatch(action, index) );

								return false;
							});
						}
					);
				}else{ return new Error("No tab buttons!"); }
				// Arrow button
				if(this.arrows){
					this.arrows.forEach(
						arrow => {
							arrow.addEventListener("click", ({type, currentTarget})=>{
								const label = arrow.getAttribute("aria-label");

								if(this.debug){
									console.group();
									console.log(`%cIndicator: ${type}`, flowStyle);
									console.log("Arrow: ", label);
									console.groupEnd();
								}

								if(this.indicatorUseage === "tab"){
									const action = label ? this.indicatorChecker(label) : Array.prototype.findIndex.call(target.parentElement.children,  arrow => arrow === target) === 0 ? PREV_TAB : NEXT_TAB;
									const index = {index : this.activeIndex};
									this.eventBinder( this.dispatch(action, index) );
								}
								
								return false;
							});
						}
					)
				}else{ return new Error("No arrow buttons!"); }
			};
			Tab.prototype.getIndex = function(_this){	
				const siblings = _this.parentElement.children;
				const index = Array.prototype.findIndex.call(siblings, sibling=> sibling === _this);   

				if(this.debug){
					console.group();
					console.log(`%cGet index : ${index}`, flowStyle);
					console.log(index === this.activeIndex);
					console.groupEnd();
				}
				return index;
			};
			Tab.prototype.keyChecker = function(_keyCode){
				const KeyMore = this.isRTL ? {} : this.addBindKeys;
				const keyList = Object.assign({
					// default keys;
					"40" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"39" : !this.isRTL ? NEXT_TAB : PREV_TAB,
					"38" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"37" : !this.isRTL ? PREV_TAB : NEXT_TAB,
					"36" : FIRST_TAB,
					"35" : LAST_TAB,
					"13" : CHOOSE
				}, KeyMore);
				const action = keyList[`${_keyCode}`]; 

				if(this.debug){
					console.group();
					console.log(`%cKey check: ${_keyCode}`, flowStyle);
					console.log("add key: ", KeyMore);
					console.groupEnd();
				}

				return action;
			};
			Tab.prototype.setFocus = function(_index){
				if(this.debug){
					console.group();
					console.log("%cSet Focus: ", flowStyle);
					console.log("Go to: ", _index);
					console.log("this: ", this);				
				}
				
				this.tabUnits[_index].focus();

				if(this.debug){
					console.groupEnd();
				}

				return this;
			};
			Tab.prototype.markActive = function(_index){
				if(this.debug){
					console.group();
					console.log("%cMarking Active tab", flowStyle);
					console.log("this: ", this);
					console.log("this context index: ", this.activeIndex);
					console.log("param index: ", _index);
					console.log("use wai-aria:", this.webAccessibility);
					console.groupEnd();
				}
				const index = _index || this.activeIndex;
				const tabUnits = this.tabUnits;
				const tabPanels = this.tabPanels;
				const activeClass = this.activeClass;
				const activeUnit = tabUnits[index];
				const activePanel = tabPanels[index];
				const useWA = this.webAccessibility;

				// set attribute
				tabUnits.forEach((unit, i) => {
					unit.tabIndex = -1;
					useWA ? unit.setAttribute("aria-selected", false) : unit.classList.remove(activeClass);
					if(index === i){
						unit.tabIndex = 0;
						useWA ? unit.setAttribute("aria-selected", true) : unit.classList.add(activeClass);
					}
				});
				
				tabPanels.forEach((panel, i) => {
					panel.classList.remove(activeClass);
					panel.removeAttribute("tabindex");
					// panel.tabIndex = -1;
					if(index === i){ 
						panel.classList.add(activeClass); 
						panel.tabIndex = 0;
					}
				});

				return this;
			};
			// scroll event
			Tab.prototype.swipe = function(){
				this.debug && console.log("attach swipe");
				this.roller.parentElement.addEventListener("mousedown", this.swipeHandleEvent, false);
				// this.roller.parentElement.addEventListener("touchstart", this.swipeHandleEvent, false);

				return this;
			};
			Tab.prototype.closedSwipe = function(){
				this.debug && console.log("dettach swipe");
				this.roller.parentElement.removeEventListener("mousedown", this.swipeHandleEvent, false);
				// this.roller.parentElement.removeEventListener("touchstart", this.swipeHandleEvent, false);
				
				return this;
			};
			Tab.prototype.swipeLifeCycle = function(_action, _event){
				const action = _action;
				const screenX = {screenX : _event.touches ? _event.touches[0].screenX : _event.screenX};

				if(this.debug){
					console.group();
					console.log("action: ", _action);
					console.log("event: ", _event);
					console.log("this: ", this);
					console.groupEnd();
				}
				
				this.eventBinder( this.dispatch(action, screenX) );
				
				return this;
			}
			Tab.prototype.swipeHandler = function(){
				const context = this;
				const dispatch = Tab.prototype.dispatch.bind(this);
				const eventBinder = Tab.prototype.eventBinder.bind(this);
				const start = Tab.prototype.swipeLifeCycle.bind(this);
				const ing = Tab.prototype.swipeLifeCycle.bind(this);
				const end = Tab.prototype.swipeLifeCycle.bind(this);
			
				return function handleEvent(_event){
					const isTouchEvent = _event.touches ? true : false;
					this.isTouchEvent = isTouchEvent;

					if(this.debug){
						console.group();
						console.log("handleEvent: ", this);
						console.log("context: ", context);
						console.log("byTouch: ", isTouchEvent);
						console.log(`%c${_event.type}`, "font-size:30px;");
						console.groupEnd();
					}

					switch(_event.type){
						case "mousedown" :
						case "touchstart" :
							// console.log("st", _event);
							start(SWIPE_START, _event);
							break; 
						case "mousemove" : 
						case "touchmove" : 
							// console.log("swp", _event);
							ing(SWIPE_MOVE, _event);
							break;
						case "mouseup" : 
						case "touchend" : 
							// console.log("ed", _event);
							end(SWIPE_END, _event);
							break;
						default : 
							return;
					}

					_event.stopPropagation();
				}
			};
			Tab.prototype.hangInSwipe = function(_containerWidth, _scrollBeltWidth){
				if(this.debug){
					console.group();
					console.log(`%cHang in Swipe`, flowStyle);
					console.log(this.name);
					console.log("breakpoint: ", _containerWidth);
					console.log("swipe activate: ", _containerWidth <= _scrollBeltWidth);
				}

				if(_containerWidth <= _scrollBeltWidth){
					this.swipe();
				}else{
					this.closedSwipe();
				}

				if(this.debug){	
					console.groupEnd();
				}

				return this;
			}
			// indicator event
			Tab.prototype.indicatorChecker = function(_label){
				if(this.debug){
					console.group();
					console.log(`%cIndicator check: ${_label}`, flowStyle);
					console.groupEnd();
				}
				const action = {
					"Previous tab" : PREV_TAB,
					"Next tab" : NEXT_TAB
				}

				return action[_label]; 
			};
			// resize event
			Tab.prototype.resizeHandler = function(_customAPIOnResize){	
				// re bind calculate api
				const calcAPI = this.calculateAPI;
				const calcContainerWidth = calcAPI.scrollContainerWidth.bind(this);
				const calcBeltWidth = calcAPI.scrollBeltWidth.bind(this);
				const calcRange = calcAPI.scrollRange.bind(this);
				const calcPosition = calcAPI.scrollPosition.bind(this);
				// debounce
				let debounce = null;
				const debounceDuration = this.debounceDuration;
				// for handleEvent block
				const context = this;
				const customAPIOnResize = _customAPIOnResize && _customAPIOnResize.bind(this);

				return function handleEvent(_event){
					const time = Date.now();
					clearTimeout(debounce);
					debounce = setTimeout(()=>{
						if(context.debug){
							console.group();
							console.log("debounce");
							console.log(context);
						}

						// update dimension
						context.containerWidth = calcContainerWidth();
						context.scrollBeltWidth = calcBeltWidth();
						context.scrollRange = calcRange(context.containerWidth, context.scrollBeltWidth);
						const changePosition = calcPosition(context.activeIndex);
						// gather dimension
						const contextObject = {
							containerWidth : context.containerWidth,
							scrollBeltWidth : context.scrollBeltWidth,
							scrollRange : context.scrollRange,
							position : changePosition
						}
						
						// use swipe check
						context.hangInSwipe(contextObject.containerWidth, contextObject.scrollBeltWidth);
						// call custom api if exist
						customAPIOnResize && customAPIOnResize(contextObject);
						// refresh scroll position
						context.animate( context.wallHeat(changePosition) );

						if(context.debug){
							console.log(contextObject);
							console.log("Debounce duration: ", Date.now() - time );
							console.groupEnd();
						}
					}, debounceDuration);
				}
			}
			// calculate
			Tab.prototype.getRenderStyleValue = function(_element, _needValue){
				if(this.debug){
					console.group();
					console.log(_element);
					console.groupEnd();
				}

				const measure = /[px, em, rem, vw, vh, %]/gi;
				let value = window.getComputedStyle(_element, null).getPropertyValue(_needValue);
				0 <= value.search(measure) ? value = parseInt(value.replace(measure, "")) : value;

				return value;
			};
			Tab.prototype.calculateAPI = (function(){
				const API = {
					tabMargin : function(_index){
						const element = this.tabUnits[_index];
						const marginOneSide = this.getRenderStyleValue(element, "margin-left"); 

						if(this.debug){
							console.group();
							console.log(`%cCalc.margin: ${marginOneSide}`, APIStyle);
							console.groupEnd();
						}

						return marginOneSide;
					},
					scrollPosition : function(_index){
						const element = this.tabUnits[_index];
						const direction = this.isRTL ? 1 : -1;
						const elemMargin = this.calculateAPI.tabMargin.call(this, _index);
						const elemOffsetRight = element.offsetLeft + element.offsetWidth;
						const elemOffsetLeft = this.isRTL ? ( (this.containerWidth - 1) - (elemOffsetRight - elemMargin) ) : element.offsetLeft; 
						const position = this.isRTL ? elemOffsetLeft * direction : (elemOffsetLeft - elemMargin) * direction;
						
						if(this.debug){
							console.group();
							console.log(`%cCalc.position: ${position}`, APIStyle);
							console.log("element: ", element);
							console.log("this.containerWidth: ", this.containerWidth);
							console.log("element.offsetLeft: ", element.offsetLeft);
							console.log("element.offsetWidth: ", element.offsetWidth);
							console.log("elemOffsetLeft: ", elemOffsetLeft);
							console.log("position: ", position);
							console.groupEnd();
						}

						return position;
					},
					scrollContainerWidth : function(){
						const width = this.rollerContainer.offsetWidth;

						if(this.debug){
							console.group();
							console.log("%cCalc.scroll_container_width", APIStyle);
							console.log(`${this.name} : %c${width}`, "color:#fff; font-size:13px; padding:3px 5px; background-color:#333;");
							console.groupEnd();
						}
						
						return width;
					},
					scrollBeltWidth : function(_index = this.activeIndex){ 
						const scrollItem = this.rootElement.querySelectorAll("[role=tab]");
						const scrollItemMargin = this.calculateAPI.tabMargin.call(this, _index);
						const baseWidth = scrollItemMargin * 2 * (scrollItem.length - 1);
						const totalWidth = Array.prototype.reduce.call(scrollItem, (total, _tab)=> total + _tab.offsetWidth, baseWidth);

						if(this.debug){
							console.group();
							console.log(scrollItem);
							console.log(`baseWidth : ${baseWidth}`);
							console.log(`totalWidth : ${totalWidth}`);
							console.groupEnd();
						}

						return totalWidth;
					},
					scrollRange : function(_containerWidth, _scrollBeltWidth){
						const coverageRatio = 1;
						const leftLimit = Math.floor( _containerWidth * 0 );
						const rightLimit = Math.floor( (_containerWidth - _scrollBeltWidth) * 1 );
						const boundRange = this.isRTL ? [(rightLimit * -1), leftLimit] : [leftLimit, rightLimit];
						
						if(this.debug){
							console.group();
							console.log(`%cCalculate.scrollRange`, APIStyle);
							console.log("this:", this);
							console.log(_containerWidth);
							console.log(_scrollBeltWidth);
							console.log(`leftRange : ${leftLimit}`);
							console.log(`rightRange : ${rightLimit}`);
							console.groupEnd();
						}

						return boundRange;
					}
				};
				return API;
			})();
			// Create
			Tab.prototype.create = function(){
				console.group();
				console.log(`%cCreate ${this.name}`, flowStyle);
				// console.log("proto : ", this);
				config.dynamicFetch && this.fetch(this.fetchCallback);
				/* pre setting */
				const initialFocus = true;
				const startIndex = this.activeIndex;
				const roller = this.roller;
				const distance = this.calculateAPI.scrollPosition.call(this, startIndex);
							
				this.tabUnits.forEach( (unit, idx) => startIndex === idx && ( this.webAccessibility ? (unit.setAttribute("aria-selected", true), unit.tabIndex = 0) : unit.tabIndex = 0 ) );			
				this.markActive(startIndex);
				this.setFocus(startIndex);
				/* event listening */
				// tab
				this.tabEvent();
				// indicator
				// this.indicatorEvent();
				if(true){
					// swipe
					this.containerWidth = this.calculateAPI.scrollContainerWidth.call(this);
					this.scrollBeltWidth = this.calculateAPI.scrollBeltWidth.call(this);
					this.scrollRange = this.calculateAPI.scrollRange.call(this, this.containerWidth, this.scrollBeltWidth);

					this.swipeHandleEvent = this.swipeHandler();
					this.hangInSwipe(this.containerWidth, this.scrollBeltWidth);
					
					// re-rendering by resize
					const customAPIOnResize = this.customAPI && this.customAPI.resize;
					const resizeHandleEvent = this.resizeHandler(customAPIOnResize);

					window.addEventListener("resize", resizeHandleEvent);
				}
				
				console.log("create done!");
				console.groupEnd();

				return this;
			};
			
			// Tab.prototype.UiUpdate = function(_index, _viewFlag){
			// 	if(this.debug){
			// 		console.group();
			// 		console.log("%cUI update", flowStyle);
			// 		console.log("index: ", _index);
			// 		console.log("view flag: ", _viewFlag);
			// 		console.log("focus element [before]: ", document.activeElement);
			// 	}

			// 	const roller = this.roller;
			// 	const distance = this.calculateAPI.scrollPosition.call(this, _index);
				
			// 	// view update;
			// 	if(_viewFlag){
			// 		this.markActive(_index);
			// 		this.setFocus(_index);
			// 	}else{
			// 		this.setFocus(_index);
			// 	}

			// 	this.animate(distance, roller);
				
			// 	if(this.debug){
			// 		console.log("focus element [after]: ", document.activeElement);
			// 		console.groupEnd();
			// 	}

			// 	return distance;
			// };
			// Tab.prototype.hangInSwipe = function(_containerWidth, _scrollBeltWidth){
			// 	const mql = window.matchMedia(`screen and (min-width: ${_containerWidth}px)`);
			// 	const condition = _containerWidth <= _scrollBeltWidth;

			// 	console.group();
			// 	console.log(`%cHang in Swipe`, flowStyle);
			// 	console.log(this.name);
			// 	console.log("mediaQueryList: ", mql);
			// 	console.log("swipe activate: ", condition);
				
			// 	if(condition){
			// 		mql.addListener((mediaQueryList)=>{
			// 			console.log(true);
			// 			mediaQueryList.matches ? 
			// 			( console.log(`${this.name} no scroll`), this.closedSwipe() ) : 
			// 			( console.log(`${this.name} has scroll`), this.swipe() );
			// 		});
					
			// 	}
			// 	console.groupEnd();
			// }
			config.autoCreate && this.create();
		}
		const tenKey = {
			"104" : "PREV",
			"100" : "PREV",
			"102" : "NEXT",
			"98" : "NEXT",
			"103" : "FIRST",
			"97" : "LAST"
		}
		const tab = document.querySelectorAll("[role=tablist]");
		const tablist1 = new Tab({
			rootElement : tab[0],
			focusWithPosition : "manual",
			indicatorUseage : "tab",
			startIndex : 1,
			webAccessibility : true,
			addBindKeys : tenKey,
			autoCreate : true,
			// debug : true,
		});
		const tablist2 = new Tab({
			rootElement : tab[1],
			focusWithPosition : "automatic",
			indicatorUseage : "scroll",
			startIndex : 4,
			direction : "rtl",
			autoCreate : false,
			// debug : true,
		});
		tablist2.customAPI = {
			resize : function(_contextObject){
				console.group();
				console.log(_contextObject);
				console.log(this);
				console.groupEnd();

				const {containerWidth, scrollBeltWidth} = _contextObject;
				containerWidth <= scrollBeltWidth ? this.roller.classList.remove("align-center") : this.roller.classList.add("align-center");
			}
		}
		tablist2.create();
		
		// dynamic template
		let tablist3 = null;
		function ajaxTEST(){
			const objAjax = new XMLHttpRequest();
			const callUrl = "./ajax-test/markup.html";
			objAjax.onreadystatechange = function(){
				if( objAjax.readyState === objAjax.DONE && objAjax.status === 200 ){
					console.log(typeof objAjax.response);
					// const dynamicHTML = new DOMParser().parseFromString(objAjax.response, "text/xml").firstElementChild;
					const dynamicHTML = document.createRange().createContextualFragment(objAjax.response);
					console.dir(dynamicHTML);
					document.body.appendChild(dynamicHTML);
					return tablist3 = new Tab({
						rootElement : document.getElementById("tab3"),
						focusWithPosition : "manual",
						indicatorUseage : "scroll",
						startIndex : 0,
						autoCreate : true,
						// debug : true,
					});
				}
			};

			objAjax.open("get", callUrl, true);
			objAjax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
			objAjax.send();
		}
		ajaxTEST();

		// dynamic data
		const tablist4 = new Tab({
			rootElement : document.querySelector(".tab4"),
			focusWithPosition : "manual",
			indicatorUseage : "tab",
			startIndex : 0,
			autoCreate : true,
			direction : "rtl",
			dynamicHTML : true,
			dynamicFetch : true, 
			fetchURL : "./ajax-test/listData.json",
			debug : true,
		});
		
		</script>
</body>
</html>